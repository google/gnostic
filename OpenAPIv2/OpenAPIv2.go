// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package openapi_v2

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/googleapis/openapi-compiler/helpers"
)

func Version() string {
	return "openapi_v2"
}

func NewAdditionalPropertiesItem(in interface{}, context *helpers.Context) (*AdditionalPropertiesItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for AdditionalPropertiesItem section: %+v", in))
	}
	x := &AdditionalPropertiesItem{}
	// Schema schema = 1;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewSchema(m, helpers.NewContext("schema", context))
		if t != nil {
			x.Oneof = &AdditionalPropertiesItem_Schema{Schema: t}
		}
	}
	// bool boolean = 2;
	v2 := helpers.MapValueForKey(m, "boolean")
	if v2 != nil {
		x.Oneof = &AdditionalPropertiesItem_Boolean{Boolean: v2.(bool)}
	}
	return x, nil
}

func NewAny(in interface{}, context *helpers.Context) (*Any, error) {
	x := &Any{}
	bytes, _ := json.Marshal(in)
	x.Value = string(bytes)
	return x, nil
}

func NewApiKeySecurity(in interface{}, context *helpers.Context) (*ApiKeySecurity, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for ApiKeySecurity section: %+v", in))
	}
	requiredKeys := []string{"in", "name", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("ApiKeySecurity does not contain all required properties ('in','name','type')")
	}
	allowedKeys := []string{"description", "in", "name", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("ApiKeySecurity includes properties not in ('description','in','name','type') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &ApiKeySecurity{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string name = 2;
	v2 := helpers.MapValueForKey(m, "name")
	if v2 != nil {
		x.Name = v2.(string)
	}
	// string in = 3;
	v3 := helpers.MapValueForKey(m, "in")
	if v3 != nil {
		x.In = v3.(string)
	}
	// string description = 4;
	v4 := helpers.MapValueForKey(m, "description")
	if v4 != nil {
		x.Description = v4.(string)
	}
	// repeated NamedAny vendor_extension = 5;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewBasicAuthenticationSecurity(in interface{}, context *helpers.Context) (*BasicAuthenticationSecurity, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for BasicAuthenticationSecurity section: %+v", in))
	}
	requiredKeys := []string{"type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("BasicAuthenticationSecurity does not contain all required properties ('type')")
	}
	allowedKeys := []string{"description", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("BasicAuthenticationSecurity includes properties not in ('description','type') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &BasicAuthenticationSecurity{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string description = 2;
	v2 := helpers.MapValueForKey(m, "description")
	if v2 != nil {
		x.Description = v2.(string)
	}
	// repeated NamedAny vendor_extension = 3;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewBodyParameter(in interface{}, context *helpers.Context) (*BodyParameter, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for BodyParameter section: %+v", in))
	}
	requiredKeys := []string{"in", "name", "schema"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("BodyParameter does not contain all required properties ('in','name','schema')")
	}
	allowedKeys := []string{"description", "in", "name", "required", "schema"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("BodyParameter includes properties not in ('description','in','name','required','schema') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &BodyParameter{}
	// string description = 1;
	v1 := helpers.MapValueForKey(m, "description")
	if v1 != nil {
		x.Description = v1.(string)
	}
	// string name = 2;
	v2 := helpers.MapValueForKey(m, "name")
	if v2 != nil {
		x.Name = v2.(string)
	}
	// string in = 3;
	v3 := helpers.MapValueForKey(m, "in")
	if v3 != nil {
		x.In = v3.(string)
	}
	// bool required = 4;
	v4 := helpers.MapValueForKey(m, "required")
	if v4 != nil {
		x.Required = v4.(bool)
	}
	// Schema schema = 5;
	v5 := helpers.MapValueForKey(m, "schema")
	if v5 != nil {
		var err error
		x.Schema, err = NewSchema(v5, helpers.NewContext("schema", context))
		if err != nil {
			return nil, helpers.ExtendError("schema", err)
		}
	}
	// repeated NamedAny vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewContact(in interface{}, context *helpers.Context) (*Contact, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Contact section: %+v", in))
	}
	allowedKeys := []string{"email", "name", "url"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Contact includes properties not in ('email','name','url') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Contact{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// string url = 2;
	v2 := helpers.MapValueForKey(m, "url")
	if v2 != nil {
		x.Url = v2.(string)
	}
	// string email = 3;
	v3 := helpers.MapValueForKey(m, "email")
	if v3 != nil {
		x.Email = v3.(string)
	}
	// repeated NamedAny vendor_extension = 4;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewDefault(in interface{}, context *helpers.Context) (*Default, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Default section: %+v", in))
	}
	x := &Default{}
	// repeated NamedAny additional_properties = 1;
	// MAP: Any
	x.AdditionalProperties = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedAny{}
		pair.Name = k
		var err error
		pair.Value, err = NewAny(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewDefinitions(in interface{}, context *helpers.Context) (*Definitions, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Definitions section: %+v", in))
	}
	x := &Definitions{}
	// repeated NamedSchema additional_properties = 1;
	// MAP: Schema
	x.AdditionalProperties = make([]*NamedSchema, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedSchema{}
		pair.Name = k
		var err error
		pair.Value, err = NewSchema(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewDocument(in interface{}, context *helpers.Context) (*Document, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Document section: %+v", in))
	}
	requiredKeys := []string{"info", "paths", "swagger"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Document does not contain all required properties ('info','paths','swagger')")
	}
	allowedKeys := []string{"basePath", "consumes", "definitions", "externalDocs", "host", "info", "parameters", "paths", "produces", "responses", "schemes", "security", "securityDefinitions", "swagger", "tags"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Document includes properties not in ('basePath','consumes','definitions','externalDocs','host','info','parameters','paths','produces','responses','schemes','security','securityDefinitions','swagger','tags') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Document{}
	// string swagger = 1;
	v1 := helpers.MapValueForKey(m, "swagger")
	if v1 != nil {
		x.Swagger = v1.(string)
	}
	// Info info = 2;
	v2 := helpers.MapValueForKey(m, "info")
	if v2 != nil {
		var err error
		x.Info, err = NewInfo(v2, helpers.NewContext("info", context))
		if err != nil {
			return nil, helpers.ExtendError("info", err)
		}
	}
	// string host = 3;
	v3 := helpers.MapValueForKey(m, "host")
	if v3 != nil {
		x.Host = v3.(string)
	}
	// string base_path = 4;
	v4 := helpers.MapValueForKey(m, "basePath")
	if v4 != nil {
		x.BasePath = v4.(string)
	}
	// repeated string schemes = 5;
	v5 := helpers.MapValueForKey(m, "schemes")
	if v5 != nil {
		v, ok := v5.([]interface{})
		if ok {
			x.Schemes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for schemes property: %+v", in))
		}
	}
	// repeated string consumes = 6;
	v6 := helpers.MapValueForKey(m, "consumes")
	if v6 != nil {
		v, ok := v6.([]interface{})
		if ok {
			x.Consumes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for consumes property: %+v", in))
		}
	}
	// repeated string produces = 7;
	v7 := helpers.MapValueForKey(m, "produces")
	if v7 != nil {
		v, ok := v7.([]interface{})
		if ok {
			x.Produces = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for produces property: %+v", in))
		}
	}
	// Paths paths = 8;
	v8 := helpers.MapValueForKey(m, "paths")
	if v8 != nil {
		var err error
		x.Paths, err = NewPaths(v8, helpers.NewContext("paths", context))
		if err != nil {
			return nil, helpers.ExtendError("paths", err)
		}
	}
	// Definitions definitions = 9;
	v9 := helpers.MapValueForKey(m, "definitions")
	if v9 != nil {
		var err error
		x.Definitions, err = NewDefinitions(v9, helpers.NewContext("definitions", context))
		if err != nil {
			return nil, helpers.ExtendError("definitions", err)
		}
	}
	// ParameterDefinitions parameters = 10;
	v10 := helpers.MapValueForKey(m, "parameters")
	if v10 != nil {
		var err error
		x.Parameters, err = NewParameterDefinitions(v10, helpers.NewContext("parameters", context))
		if err != nil {
			return nil, helpers.ExtendError("parameters", err)
		}
	}
	// ResponseDefinitions responses = 11;
	v11 := helpers.MapValueForKey(m, "responses")
	if v11 != nil {
		var err error
		x.Responses, err = NewResponseDefinitions(v11, helpers.NewContext("responses", context))
		if err != nil {
			return nil, helpers.ExtendError("responses", err)
		}
	}
	// repeated SecurityRequirement security = 12;
	v12 := helpers.MapValueForKey(m, "security")
	if v12 != nil {
		// repeated class SecurityRequirement
		x.Security = make([]*SecurityRequirement, 0)
		a, ok := v12.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewSecurityRequirement(item, helpers.NewContext("security", context))
				if err != nil {
					return nil, err
				}
				x.Security = append(x.Security, y)
			}
		}
	}
	// SecurityDefinitions security_definitions = 13;
	v13 := helpers.MapValueForKey(m, "securityDefinitions")
	if v13 != nil {
		var err error
		x.SecurityDefinitions, err = NewSecurityDefinitions(v13, helpers.NewContext("securityDefinitions", context))
		if err != nil {
			return nil, helpers.ExtendError("securityDefinitions", err)
		}
	}
	// repeated Tag tags = 14;
	v14 := helpers.MapValueForKey(m, "tags")
	if v14 != nil {
		// repeated class Tag
		x.Tags = make([]*Tag, 0)
		a, ok := v14.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewTag(item, helpers.NewContext("tags", context))
				if err != nil {
					return nil, err
				}
				x.Tags = append(x.Tags, y)
			}
		}
	}
	// ExternalDocs external_docs = 15;
	v15 := helpers.MapValueForKey(m, "externalDocs")
	if v15 != nil {
		var err error
		x.ExternalDocs, err = NewExternalDocs(v15, helpers.NewContext("externalDocs", context))
		if err != nil {
			return nil, helpers.ExtendError("externalDocs", err)
		}
	}
	return x, nil
}

func NewExamples(in interface{}, context *helpers.Context) (*Examples, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Examples section: %+v", in))
	}
	x := &Examples{}
	// repeated NamedAny additional_properties = 1;
	// MAP: Any
	x.AdditionalProperties = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedAny{}
		pair.Name = k
		var err error
		pair.Value, err = NewAny(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewExternalDocs(in interface{}, context *helpers.Context) (*ExternalDocs, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for ExternalDocs section: %+v", in))
	}
	requiredKeys := []string{"url"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("ExternalDocs does not contain all required properties ('url')")
	}
	allowedKeys := []string{"description", "url"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("ExternalDocs includes properties not in ('description','url') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &ExternalDocs{}
	// string description = 1;
	v1 := helpers.MapValueForKey(m, "description")
	if v1 != nil {
		x.Description = v1.(string)
	}
	// string url = 2;
	v2 := helpers.MapValueForKey(m, "url")
	if v2 != nil {
		x.Url = v2.(string)
	}
	// repeated NamedAny vendor_extension = 3;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewFileSchema(in interface{}, context *helpers.Context) (*FileSchema, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for FileSchema section: %+v", in))
	}
	requiredKeys := []string{"type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("FileSchema does not contain all required properties ('type')")
	}
	allowedKeys := []string{"default", "description", "example", "externalDocs", "format", "readOnly", "required", "title", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("FileSchema includes properties not in ('default','description','example','externalDocs','format','readOnly','required','title','type') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &FileSchema{}
	// string format = 1;
	v1 := helpers.MapValueForKey(m, "format")
	if v1 != nil {
		x.Format = v1.(string)
	}
	// string title = 2;
	v2 := helpers.MapValueForKey(m, "title")
	if v2 != nil {
		x.Title = v2.(string)
	}
	// string description = 3;
	v3 := helpers.MapValueForKey(m, "description")
	if v3 != nil {
		x.Description = v3.(string)
	}
	// Any default = 4;
	v4 := helpers.MapValueForKey(m, "default")
	if v4 != nil {
		var err error
		x.Default, err = NewAny(v4, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// repeated string required = 5;
	v5 := helpers.MapValueForKey(m, "required")
	if v5 != nil {
		v, ok := v5.([]interface{})
		if ok {
			x.Required = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for required property: %+v", in))
		}
	}
	// string type = 6;
	v6 := helpers.MapValueForKey(m, "type")
	if v6 != nil {
		x.Type = v6.(string)
	}
	// bool read_only = 7;
	v7 := helpers.MapValueForKey(m, "readOnly")
	if v7 != nil {
		x.ReadOnly = v7.(bool)
	}
	// ExternalDocs external_docs = 8;
	v8 := helpers.MapValueForKey(m, "externalDocs")
	if v8 != nil {
		var err error
		x.ExternalDocs, err = NewExternalDocs(v8, helpers.NewContext("externalDocs", context))
		if err != nil {
			return nil, helpers.ExtendError("externalDocs", err)
		}
	}
	// Any example = 9;
	v9 := helpers.MapValueForKey(m, "example")
	if v9 != nil {
		var err error
		x.Example, err = NewAny(v9, helpers.NewContext("example", context))
		if err != nil {
			return nil, helpers.ExtendError("example", err)
		}
	}
	// repeated NamedAny vendor_extension = 10;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewFormDataParameterSubSchema(in interface{}, context *helpers.Context) (*FormDataParameterSubSchema, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for FormDataParameterSubSchema section: %+v", in))
	}
	allowedKeys := []string{"allowEmptyValue", "collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("FormDataParameterSubSchema includes properties not in ('allowEmptyValue','collectionFormat','default','description','enum','exclusiveMaximum','exclusiveMinimum','format','in','items','maxItems','maxLength','maximum','minItems','minLength','minimum','multipleOf','name','pattern','required','type','uniqueItems') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &FormDataParameterSubSchema{}
	// bool required = 1;
	v1 := helpers.MapValueForKey(m, "required")
	if v1 != nil {
		x.Required = v1.(bool)
	}
	// string in = 2;
	v2 := helpers.MapValueForKey(m, "in")
	if v2 != nil {
		x.In = v2.(string)
	}
	// string description = 3;
	v3 := helpers.MapValueForKey(m, "description")
	if v3 != nil {
		x.Description = v3.(string)
	}
	// string name = 4;
	v4 := helpers.MapValueForKey(m, "name")
	if v4 != nil {
		x.Name = v4.(string)
	}
	// bool allow_empty_value = 5;
	v5 := helpers.MapValueForKey(m, "allowEmptyValue")
	if v5 != nil {
		x.AllowEmptyValue = v5.(bool)
	}
	// string type = 6;
	v6 := helpers.MapValueForKey(m, "type")
	if v6 != nil {
		x.Type = v6.(string)
	}
	// string format = 7;
	v7 := helpers.MapValueForKey(m, "format")
	if v7 != nil {
		x.Format = v7.(string)
	}
	// PrimitivesItems items = 8;
	v8 := helpers.MapValueForKey(m, "items")
	if v8 != nil {
		var err error
		x.Items, err = NewPrimitivesItems(v8, helpers.NewContext("items", context))
		if err != nil {
			return nil, helpers.ExtendError("items", err)
		}
	}
	// string collection_format = 9;
	v9 := helpers.MapValueForKey(m, "collectionFormat")
	if v9 != nil {
		x.CollectionFormat = v9.(string)
	}
	// Any default = 10;
	v10 := helpers.MapValueForKey(m, "default")
	if v10 != nil {
		var err error
		x.Default, err = NewAny(v10, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// float maximum = 11;
	v11 := helpers.MapValueForKey(m, "maximum")
	if v11 != nil {
		x.Maximum = v11.(float64)
	}
	// bool exclusive_maximum = 12;
	v12 := helpers.MapValueForKey(m, "exclusiveMaximum")
	if v12 != nil {
		x.ExclusiveMaximum = v12.(bool)
	}
	// float minimum = 13;
	v13 := helpers.MapValueForKey(m, "minimum")
	if v13 != nil {
		x.Minimum = v13.(float64)
	}
	// bool exclusive_minimum = 14;
	v14 := helpers.MapValueForKey(m, "exclusiveMinimum")
	if v14 != nil {
		x.ExclusiveMinimum = v14.(bool)
	}
	// int64 max_length = 15;
	v15 := helpers.MapValueForKey(m, "maxLength")
	if v15 != nil {
		x.MaxLength = v15.(int64)
	}
	// int64 min_length = 16;
	v16 := helpers.MapValueForKey(m, "minLength")
	if v16 != nil {
		x.MinLength = v16.(int64)
	}
	// string pattern = 17;
	v17 := helpers.MapValueForKey(m, "pattern")
	if v17 != nil {
		x.Pattern = v17.(string)
	}
	// int64 max_items = 18;
	v18 := helpers.MapValueForKey(m, "maxItems")
	if v18 != nil {
		x.MaxItems = v18.(int64)
	}
	// int64 min_items = 19;
	v19 := helpers.MapValueForKey(m, "minItems")
	if v19 != nil {
		x.MinItems = v19.(int64)
	}
	// bool unique_items = 20;
	v20 := helpers.MapValueForKey(m, "uniqueItems")
	if v20 != nil {
		x.UniqueItems = v20.(bool)
	}
	// repeated Any enum = 21;
	v21 := helpers.MapValueForKey(m, "enum")
	if v21 != nil {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := v21.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewAny(item, helpers.NewContext("enum", context))
				if err != nil {
					return nil, err
				}
				x.Enum = append(x.Enum, y)
			}
		}
	}
	// float multiple_of = 22;
	v22 := helpers.MapValueForKey(m, "multipleOf")
	if v22 != nil {
		x.MultipleOf = v22.(float64)
	}
	// repeated NamedAny vendor_extension = 23;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewHeader(in interface{}, context *helpers.Context) (*Header, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Header section: %+v", in))
	}
	requiredKeys := []string{"type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Header does not contain all required properties ('type')")
	}
	allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "pattern", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Header includes properties not in ('collectionFormat','default','description','enum','exclusiveMaximum','exclusiveMinimum','format','items','maxItems','maxLength','maximum','minItems','minLength','minimum','multipleOf','pattern','type','uniqueItems') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Header{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string format = 2;
	v2 := helpers.MapValueForKey(m, "format")
	if v2 != nil {
		x.Format = v2.(string)
	}
	// PrimitivesItems items = 3;
	v3 := helpers.MapValueForKey(m, "items")
	if v3 != nil {
		var err error
		x.Items, err = NewPrimitivesItems(v3, helpers.NewContext("items", context))
		if err != nil {
			return nil, helpers.ExtendError("items", err)
		}
	}
	// string collection_format = 4;
	v4 := helpers.MapValueForKey(m, "collectionFormat")
	if v4 != nil {
		x.CollectionFormat = v4.(string)
	}
	// Any default = 5;
	v5 := helpers.MapValueForKey(m, "default")
	if v5 != nil {
		var err error
		x.Default, err = NewAny(v5, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// float maximum = 6;
	v6 := helpers.MapValueForKey(m, "maximum")
	if v6 != nil {
		x.Maximum = v6.(float64)
	}
	// bool exclusive_maximum = 7;
	v7 := helpers.MapValueForKey(m, "exclusiveMaximum")
	if v7 != nil {
		x.ExclusiveMaximum = v7.(bool)
	}
	// float minimum = 8;
	v8 := helpers.MapValueForKey(m, "minimum")
	if v8 != nil {
		x.Minimum = v8.(float64)
	}
	// bool exclusive_minimum = 9;
	v9 := helpers.MapValueForKey(m, "exclusiveMinimum")
	if v9 != nil {
		x.ExclusiveMinimum = v9.(bool)
	}
	// int64 max_length = 10;
	v10 := helpers.MapValueForKey(m, "maxLength")
	if v10 != nil {
		x.MaxLength = v10.(int64)
	}
	// int64 min_length = 11;
	v11 := helpers.MapValueForKey(m, "minLength")
	if v11 != nil {
		x.MinLength = v11.(int64)
	}
	// string pattern = 12;
	v12 := helpers.MapValueForKey(m, "pattern")
	if v12 != nil {
		x.Pattern = v12.(string)
	}
	// int64 max_items = 13;
	v13 := helpers.MapValueForKey(m, "maxItems")
	if v13 != nil {
		x.MaxItems = v13.(int64)
	}
	// int64 min_items = 14;
	v14 := helpers.MapValueForKey(m, "minItems")
	if v14 != nil {
		x.MinItems = v14.(int64)
	}
	// bool unique_items = 15;
	v15 := helpers.MapValueForKey(m, "uniqueItems")
	if v15 != nil {
		x.UniqueItems = v15.(bool)
	}
	// repeated Any enum = 16;
	v16 := helpers.MapValueForKey(m, "enum")
	if v16 != nil {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := v16.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewAny(item, helpers.NewContext("enum", context))
				if err != nil {
					return nil, err
				}
				x.Enum = append(x.Enum, y)
			}
		}
	}
	// float multiple_of = 17;
	v17 := helpers.MapValueForKey(m, "multipleOf")
	if v17 != nil {
		x.MultipleOf = v17.(float64)
	}
	// string description = 18;
	v18 := helpers.MapValueForKey(m, "description")
	if v18 != nil {
		x.Description = v18.(string)
	}
	// repeated NamedAny vendor_extension = 19;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewHeaderParameterSubSchema(in interface{}, context *helpers.Context) (*HeaderParameterSubSchema, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for HeaderParameterSubSchema section: %+v", in))
	}
	allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("HeaderParameterSubSchema includes properties not in ('collectionFormat','default','description','enum','exclusiveMaximum','exclusiveMinimum','format','in','items','maxItems','maxLength','maximum','minItems','minLength','minimum','multipleOf','name','pattern','required','type','uniqueItems') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &HeaderParameterSubSchema{}
	// bool required = 1;
	v1 := helpers.MapValueForKey(m, "required")
	if v1 != nil {
		x.Required = v1.(bool)
	}
	// string in = 2;
	v2 := helpers.MapValueForKey(m, "in")
	if v2 != nil {
		x.In = v2.(string)
	}
	// string description = 3;
	v3 := helpers.MapValueForKey(m, "description")
	if v3 != nil {
		x.Description = v3.(string)
	}
	// string name = 4;
	v4 := helpers.MapValueForKey(m, "name")
	if v4 != nil {
		x.Name = v4.(string)
	}
	// string type = 5;
	v5 := helpers.MapValueForKey(m, "type")
	if v5 != nil {
		x.Type = v5.(string)
	}
	// string format = 6;
	v6 := helpers.MapValueForKey(m, "format")
	if v6 != nil {
		x.Format = v6.(string)
	}
	// PrimitivesItems items = 7;
	v7 := helpers.MapValueForKey(m, "items")
	if v7 != nil {
		var err error
		x.Items, err = NewPrimitivesItems(v7, helpers.NewContext("items", context))
		if err != nil {
			return nil, helpers.ExtendError("items", err)
		}
	}
	// string collection_format = 8;
	v8 := helpers.MapValueForKey(m, "collectionFormat")
	if v8 != nil {
		x.CollectionFormat = v8.(string)
	}
	// Any default = 9;
	v9 := helpers.MapValueForKey(m, "default")
	if v9 != nil {
		var err error
		x.Default, err = NewAny(v9, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// float maximum = 10;
	v10 := helpers.MapValueForKey(m, "maximum")
	if v10 != nil {
		x.Maximum = v10.(float64)
	}
	// bool exclusive_maximum = 11;
	v11 := helpers.MapValueForKey(m, "exclusiveMaximum")
	if v11 != nil {
		x.ExclusiveMaximum = v11.(bool)
	}
	// float minimum = 12;
	v12 := helpers.MapValueForKey(m, "minimum")
	if v12 != nil {
		x.Minimum = v12.(float64)
	}
	// bool exclusive_minimum = 13;
	v13 := helpers.MapValueForKey(m, "exclusiveMinimum")
	if v13 != nil {
		x.ExclusiveMinimum = v13.(bool)
	}
	// int64 max_length = 14;
	v14 := helpers.MapValueForKey(m, "maxLength")
	if v14 != nil {
		x.MaxLength = v14.(int64)
	}
	// int64 min_length = 15;
	v15 := helpers.MapValueForKey(m, "minLength")
	if v15 != nil {
		x.MinLength = v15.(int64)
	}
	// string pattern = 16;
	v16 := helpers.MapValueForKey(m, "pattern")
	if v16 != nil {
		x.Pattern = v16.(string)
	}
	// int64 max_items = 17;
	v17 := helpers.MapValueForKey(m, "maxItems")
	if v17 != nil {
		x.MaxItems = v17.(int64)
	}
	// int64 min_items = 18;
	v18 := helpers.MapValueForKey(m, "minItems")
	if v18 != nil {
		x.MinItems = v18.(int64)
	}
	// bool unique_items = 19;
	v19 := helpers.MapValueForKey(m, "uniqueItems")
	if v19 != nil {
		x.UniqueItems = v19.(bool)
	}
	// repeated Any enum = 20;
	v20 := helpers.MapValueForKey(m, "enum")
	if v20 != nil {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := v20.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewAny(item, helpers.NewContext("enum", context))
				if err != nil {
					return nil, err
				}
				x.Enum = append(x.Enum, y)
			}
		}
	}
	// float multiple_of = 21;
	v21 := helpers.MapValueForKey(m, "multipleOf")
	if v21 != nil {
		x.MultipleOf = v21.(float64)
	}
	// repeated NamedAny vendor_extension = 22;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewHeaders(in interface{}, context *helpers.Context) (*Headers, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Headers section: %+v", in))
	}
	x := &Headers{}
	// repeated NamedHeader additional_properties = 1;
	// MAP: Header
	x.AdditionalProperties = make([]*NamedHeader, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedHeader{}
		pair.Name = k
		var err error
		pair.Value, err = NewHeader(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewInfo(in interface{}, context *helpers.Context) (*Info, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Info section: %+v", in))
	}
	requiredKeys := []string{"title", "version"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Info does not contain all required properties ('title','version')")
	}
	allowedKeys := []string{"contact", "description", "license", "termsOfService", "title", "version"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Info includes properties not in ('contact','description','license','termsOfService','title','version') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Info{}
	// string title = 1;
	v1 := helpers.MapValueForKey(m, "title")
	if v1 != nil {
		x.Title = v1.(string)
	}
	// string version = 2;
	v2 := helpers.MapValueForKey(m, "version")
	if v2 != nil {
		x.Version = v2.(string)
	}
	// string description = 3;
	v3 := helpers.MapValueForKey(m, "description")
	if v3 != nil {
		x.Description = v3.(string)
	}
	// string terms_of_service = 4;
	v4 := helpers.MapValueForKey(m, "termsOfService")
	if v4 != nil {
		x.TermsOfService = v4.(string)
	}
	// Contact contact = 5;
	v5 := helpers.MapValueForKey(m, "contact")
	if v5 != nil {
		var err error
		x.Contact, err = NewContact(v5, helpers.NewContext("contact", context))
		if err != nil {
			return nil, helpers.ExtendError("contact", err)
		}
	}
	// License license = 6;
	v6 := helpers.MapValueForKey(m, "license")
	if v6 != nil {
		var err error
		x.License, err = NewLicense(v6, helpers.NewContext("license", context))
		if err != nil {
			return nil, helpers.ExtendError("license", err)
		}
	}
	// repeated NamedAny vendor_extension = 7;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewItemsItem(in interface{}, context *helpers.Context) (*ItemsItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for item array: %+v", in))
	}
	x := &ItemsItem{}
	if ok {
		x.Schema = make([]*Schema, 0)
		y, err := NewSchema(m, helpers.NewContext("<array>", context))
		if err != nil {
			return nil, err
		}
		x.Schema = append(x.Schema, y)
	} else {
		return nil, errors.New(fmt.Sprintf("unexpected value for item array: %+v", in))
	}
	return x, nil
}

func NewJsonReference(in interface{}, context *helpers.Context) (*JsonReference, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for JsonReference section: %+v", in))
	}
	requiredKeys := []string{"$ref"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("JsonReference does not contain all required properties ('$ref')")
	}
	allowedKeys := []string{"$ref"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("JsonReference includes properties not in ('$ref') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &JsonReference{}
	// string _ref = 1;
	v1 := helpers.MapValueForKey(m, "$ref")
	if v1 != nil {
		x.XRef = v1.(string)
	}
	return x, nil
}

func NewLicense(in interface{}, context *helpers.Context) (*License, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for License section: %+v", in))
	}
	requiredKeys := []string{"name"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("License does not contain all required properties ('name')")
	}
	allowedKeys := []string{"name", "url"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("License includes properties not in ('name','url') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &License{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// string url = 2;
	v2 := helpers.MapValueForKey(m, "url")
	if v2 != nil {
		x.Url = v2.(string)
	}
	// repeated NamedAny vendor_extension = 3;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewNamedAny(in interface{}, context *helpers.Context) (*NamedAny, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedAny section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedAny includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedAny{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// Any value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewAny(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedHeader(in interface{}, context *helpers.Context) (*NamedHeader, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedHeader section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedHeader includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedHeader{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// Header value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewHeader(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedParameter(in interface{}, context *helpers.Context) (*NamedParameter, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedParameter section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedParameter includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedParameter{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// Parameter value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewParameter(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedPathItem(in interface{}, context *helpers.Context) (*NamedPathItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedPathItem section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedPathItem includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedPathItem{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// PathItem value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewPathItem(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedResponse(in interface{}, context *helpers.Context) (*NamedResponse, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedResponse section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedResponse includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedResponse{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// Response value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewResponse(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedResponseValue(in interface{}, context *helpers.Context) (*NamedResponseValue, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedResponseValue section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedResponseValue includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedResponseValue{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// ResponseValue value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewResponseValue(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedSchema(in interface{}, context *helpers.Context) (*NamedSchema, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedSchema section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedSchema includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedSchema{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// Schema value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewSchema(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedSecurityDefinitionsItem(in interface{}, context *helpers.Context) (*NamedSecurityDefinitionsItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedSecurityDefinitionsItem section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedSecurityDefinitionsItem includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedSecurityDefinitionsItem{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// SecurityDefinitionsItem value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewSecurityDefinitionsItem(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNamedString(in interface{}, context *helpers.Context) (*NamedString, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedString section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedString includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedString{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// string value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		x.Value = v2.(string)
	}
	return x, nil
}

func NewNamedStringArray(in interface{}, context *helpers.Context) (*NamedStringArray, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NamedStringArray section: %+v", in))
	}
	allowedKeys := []string{"name", "value"}
	allowedPatterns := []string{}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("NamedStringArray includes properties not in ('name','value') or (): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &NamedStringArray{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// StringArray value = 2;
	v2 := helpers.MapValueForKey(m, "value")
	if v2 != nil {
		var err error
		x.Value, err = NewStringArray(v2, helpers.NewContext("value", context))
		if err != nil {
			return nil, helpers.ExtendError("value", err)
		}
	}
	return x, nil
}

func NewNonBodyParameter(in interface{}, context *helpers.Context) (*NonBodyParameter, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for NonBodyParameter section: %+v", in))
	}
	requiredKeys := []string{"in", "name", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("NonBodyParameter does not contain all required properties ('in','name','type')")
	}
	x := &NonBodyParameter{}
	// HeaderParameterSubSchema header_parameter_sub_schema = 1;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewHeaderParameterSubSchema(m, helpers.NewContext("headerParameterSubSchema", context))
		if t != nil {
			x.Oneof = &NonBodyParameter_HeaderParameterSubSchema{HeaderParameterSubSchema: t}
		}
	}
	// FormDataParameterSubSchema form_data_parameter_sub_schema = 2;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewFormDataParameterSubSchema(m, helpers.NewContext("formDataParameterSubSchema", context))
		if t != nil {
			x.Oneof = &NonBodyParameter_FormDataParameterSubSchema{FormDataParameterSubSchema: t}
		}
	}
	// QueryParameterSubSchema query_parameter_sub_schema = 3;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewQueryParameterSubSchema(m, helpers.NewContext("queryParameterSubSchema", context))
		if t != nil {
			x.Oneof = &NonBodyParameter_QueryParameterSubSchema{QueryParameterSubSchema: t}
		}
	}
	// PathParameterSubSchema path_parameter_sub_schema = 4;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewPathParameterSubSchema(m, helpers.NewContext("pathParameterSubSchema", context))
		if t != nil {
			x.Oneof = &NonBodyParameter_PathParameterSubSchema{PathParameterSubSchema: t}
		}
	}
	return x, nil
}

func NewOauth2AccessCodeSecurity(in interface{}, context *helpers.Context) (*Oauth2AccessCodeSecurity, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Oauth2AccessCodeSecurity section: %+v", in))
	}
	requiredKeys := []string{"authorizationUrl", "flow", "tokenUrl", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Oauth2AccessCodeSecurity does not contain all required properties ('authorizationUrl','flow','tokenUrl','type')")
	}
	allowedKeys := []string{"authorizationUrl", "description", "flow", "scopes", "tokenUrl", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Oauth2AccessCodeSecurity includes properties not in ('authorizationUrl','description','flow','scopes','tokenUrl','type') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Oauth2AccessCodeSecurity{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string flow = 2;
	v2 := helpers.MapValueForKey(m, "flow")
	if v2 != nil {
		x.Flow = v2.(string)
	}
	// Oauth2Scopes scopes = 3;
	v3 := helpers.MapValueForKey(m, "scopes")
	if v3 != nil {
		var err error
		x.Scopes, err = NewOauth2Scopes(v3, helpers.NewContext("scopes", context))
		if err != nil {
			return nil, helpers.ExtendError("scopes", err)
		}
	}
	// string authorization_url = 4;
	v4 := helpers.MapValueForKey(m, "authorizationUrl")
	if v4 != nil {
		x.AuthorizationUrl = v4.(string)
	}
	// string token_url = 5;
	v5 := helpers.MapValueForKey(m, "tokenUrl")
	if v5 != nil {
		x.TokenUrl = v5.(string)
	}
	// string description = 6;
	v6 := helpers.MapValueForKey(m, "description")
	if v6 != nil {
		x.Description = v6.(string)
	}
	// repeated NamedAny vendor_extension = 7;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewOauth2ApplicationSecurity(in interface{}, context *helpers.Context) (*Oauth2ApplicationSecurity, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Oauth2ApplicationSecurity section: %+v", in))
	}
	requiredKeys := []string{"flow", "tokenUrl", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Oauth2ApplicationSecurity does not contain all required properties ('flow','tokenUrl','type')")
	}
	allowedKeys := []string{"description", "flow", "scopes", "tokenUrl", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Oauth2ApplicationSecurity includes properties not in ('description','flow','scopes','tokenUrl','type') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Oauth2ApplicationSecurity{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string flow = 2;
	v2 := helpers.MapValueForKey(m, "flow")
	if v2 != nil {
		x.Flow = v2.(string)
	}
	// Oauth2Scopes scopes = 3;
	v3 := helpers.MapValueForKey(m, "scopes")
	if v3 != nil {
		var err error
		x.Scopes, err = NewOauth2Scopes(v3, helpers.NewContext("scopes", context))
		if err != nil {
			return nil, helpers.ExtendError("scopes", err)
		}
	}
	// string token_url = 4;
	v4 := helpers.MapValueForKey(m, "tokenUrl")
	if v4 != nil {
		x.TokenUrl = v4.(string)
	}
	// string description = 5;
	v5 := helpers.MapValueForKey(m, "description")
	if v5 != nil {
		x.Description = v5.(string)
	}
	// repeated NamedAny vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewOauth2ImplicitSecurity(in interface{}, context *helpers.Context) (*Oauth2ImplicitSecurity, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Oauth2ImplicitSecurity section: %+v", in))
	}
	requiredKeys := []string{"authorizationUrl", "flow", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Oauth2ImplicitSecurity does not contain all required properties ('authorizationUrl','flow','type')")
	}
	allowedKeys := []string{"authorizationUrl", "description", "flow", "scopes", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Oauth2ImplicitSecurity includes properties not in ('authorizationUrl','description','flow','scopes','type') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Oauth2ImplicitSecurity{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string flow = 2;
	v2 := helpers.MapValueForKey(m, "flow")
	if v2 != nil {
		x.Flow = v2.(string)
	}
	// Oauth2Scopes scopes = 3;
	v3 := helpers.MapValueForKey(m, "scopes")
	if v3 != nil {
		var err error
		x.Scopes, err = NewOauth2Scopes(v3, helpers.NewContext("scopes", context))
		if err != nil {
			return nil, helpers.ExtendError("scopes", err)
		}
	}
	// string authorization_url = 4;
	v4 := helpers.MapValueForKey(m, "authorizationUrl")
	if v4 != nil {
		x.AuthorizationUrl = v4.(string)
	}
	// string description = 5;
	v5 := helpers.MapValueForKey(m, "description")
	if v5 != nil {
		x.Description = v5.(string)
	}
	// repeated NamedAny vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewOauth2PasswordSecurity(in interface{}, context *helpers.Context) (*Oauth2PasswordSecurity, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Oauth2PasswordSecurity section: %+v", in))
	}
	requiredKeys := []string{"flow", "tokenUrl", "type"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Oauth2PasswordSecurity does not contain all required properties ('flow','tokenUrl','type')")
	}
	allowedKeys := []string{"description", "flow", "scopes", "tokenUrl", "type"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Oauth2PasswordSecurity includes properties not in ('description','flow','scopes','tokenUrl','type') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Oauth2PasswordSecurity{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string flow = 2;
	v2 := helpers.MapValueForKey(m, "flow")
	if v2 != nil {
		x.Flow = v2.(string)
	}
	// Oauth2Scopes scopes = 3;
	v3 := helpers.MapValueForKey(m, "scopes")
	if v3 != nil {
		var err error
		x.Scopes, err = NewOauth2Scopes(v3, helpers.NewContext("scopes", context))
		if err != nil {
			return nil, helpers.ExtendError("scopes", err)
		}
	}
	// string token_url = 4;
	v4 := helpers.MapValueForKey(m, "tokenUrl")
	if v4 != nil {
		x.TokenUrl = v4.(string)
	}
	// string description = 5;
	v5 := helpers.MapValueForKey(m, "description")
	if v5 != nil {
		x.Description = v5.(string)
	}
	// repeated NamedAny vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewOauth2Scopes(in interface{}, context *helpers.Context) (*Oauth2Scopes, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Oauth2Scopes section: %+v", in))
	}
	x := &Oauth2Scopes{}
	// repeated NamedString additional_properties = 1;
	// MAP: string
	x.AdditionalProperties = make([]*NamedString, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedString{}
		pair.Name = k
		pair.Value = v.(string)
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewOperation(in interface{}, context *helpers.Context) (*Operation, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Operation section: %+v", in))
	}
	requiredKeys := []string{"responses"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Operation does not contain all required properties ('responses')")
	}
	allowedKeys := []string{"consumes", "deprecated", "description", "externalDocs", "operationId", "parameters", "produces", "responses", "schemes", "security", "summary", "tags"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Operation includes properties not in ('consumes','deprecated','description','externalDocs','operationId','parameters','produces','responses','schemes','security','summary','tags') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Operation{}
	// repeated string tags = 1;
	v1 := helpers.MapValueForKey(m, "tags")
	if v1 != nil {
		v, ok := v1.([]interface{})
		if ok {
			x.Tags = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for tags property: %+v", in))
		}
	}
	// string summary = 2;
	v2 := helpers.MapValueForKey(m, "summary")
	if v2 != nil {
		x.Summary = v2.(string)
	}
	// string description = 3;
	v3 := helpers.MapValueForKey(m, "description")
	if v3 != nil {
		x.Description = v3.(string)
	}
	// ExternalDocs external_docs = 4;
	v4 := helpers.MapValueForKey(m, "externalDocs")
	if v4 != nil {
		var err error
		x.ExternalDocs, err = NewExternalDocs(v4, helpers.NewContext("externalDocs", context))
		if err != nil {
			return nil, helpers.ExtendError("externalDocs", err)
		}
	}
	// string operation_id = 5;
	v5 := helpers.MapValueForKey(m, "operationId")
	if v5 != nil {
		x.OperationId = v5.(string)
	}
	// repeated string produces = 6;
	v6 := helpers.MapValueForKey(m, "produces")
	if v6 != nil {
		v, ok := v6.([]interface{})
		if ok {
			x.Produces = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for produces property: %+v", in))
		}
	}
	// repeated string consumes = 7;
	v7 := helpers.MapValueForKey(m, "consumes")
	if v7 != nil {
		v, ok := v7.([]interface{})
		if ok {
			x.Consumes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for consumes property: %+v", in))
		}
	}
	// repeated ParametersItem parameters = 8;
	v8 := helpers.MapValueForKey(m, "parameters")
	if v8 != nil {
		// repeated class ParametersItem
		x.Parameters = make([]*ParametersItem, 0)
		a, ok := v8.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewParametersItem(item, helpers.NewContext("parameters", context))
				if err != nil {
					return nil, err
				}
				x.Parameters = append(x.Parameters, y)
			}
		}
	}
	// Responses responses = 9;
	v9 := helpers.MapValueForKey(m, "responses")
	if v9 != nil {
		var err error
		x.Responses, err = NewResponses(v9, helpers.NewContext("responses", context))
		if err != nil {
			return nil, helpers.ExtendError("responses", err)
		}
	}
	// repeated string schemes = 10;
	v10 := helpers.MapValueForKey(m, "schemes")
	if v10 != nil {
		v, ok := v10.([]interface{})
		if ok {
			x.Schemes = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for schemes property: %+v", in))
		}
	}
	// bool deprecated = 11;
	v11 := helpers.MapValueForKey(m, "deprecated")
	if v11 != nil {
		x.Deprecated = v11.(bool)
	}
	// repeated SecurityRequirement security = 12;
	v12 := helpers.MapValueForKey(m, "security")
	if v12 != nil {
		// repeated class SecurityRequirement
		x.Security = make([]*SecurityRequirement, 0)
		a, ok := v12.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewSecurityRequirement(item, helpers.NewContext("security", context))
				if err != nil {
					return nil, err
				}
				x.Security = append(x.Security, y)
			}
		}
	}
	// repeated NamedAny vendor_extension = 13;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewParameter(in interface{}, context *helpers.Context) (*Parameter, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Parameter section: %+v", in))
	}
	x := &Parameter{}
	// BodyParameter body_parameter = 1;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewBodyParameter(m, helpers.NewContext("bodyParameter", context))
		if t != nil {
			x.Oneof = &Parameter_BodyParameter{BodyParameter: t}
		}
	}
	// NonBodyParameter non_body_parameter = 2;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewNonBodyParameter(m, helpers.NewContext("nonBodyParameter", context))
		if t != nil {
			x.Oneof = &Parameter_NonBodyParameter{NonBodyParameter: t}
		}
	}
	return x, nil
}

func NewParameterDefinitions(in interface{}, context *helpers.Context) (*ParameterDefinitions, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for ParameterDefinitions section: %+v", in))
	}
	x := &ParameterDefinitions{}
	// repeated NamedParameter additional_properties = 1;
	// MAP: Parameter
	x.AdditionalProperties = make([]*NamedParameter, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedParameter{}
		pair.Name = k
		var err error
		pair.Value, err = NewParameter(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewParametersItem(in interface{}, context *helpers.Context) (*ParametersItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for ParametersItem section: %+v", in))
	}
	x := &ParametersItem{}
	// Parameter parameter = 1;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewParameter(m, helpers.NewContext("parameter", context))
		if t != nil {
			x.Oneof = &ParametersItem_Parameter{Parameter: t}
		}
	}
	// JsonReference json_reference = 2;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewJsonReference(m, helpers.NewContext("jsonReference", context))
		if t != nil {
			x.Oneof = &ParametersItem_JsonReference{JsonReference: t}
		}
	}
	return x, nil
}

func NewPathItem(in interface{}, context *helpers.Context) (*PathItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for PathItem section: %+v", in))
	}
	allowedKeys := []string{"$ref", "delete", "get", "head", "options", "parameters", "patch", "post", "put"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("PathItem includes properties not in ('$ref','delete','get','head','options','parameters','patch','post','put') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &PathItem{}
	// string _ref = 1;
	v1 := helpers.MapValueForKey(m, "$ref")
	if v1 != nil {
		x.XRef = v1.(string)
	}
	// Operation get = 2;
	v2 := helpers.MapValueForKey(m, "get")
	if v2 != nil {
		var err error
		x.Get, err = NewOperation(v2, helpers.NewContext("get", context))
		if err != nil {
			return nil, helpers.ExtendError("get", err)
		}
	}
	// Operation put = 3;
	v3 := helpers.MapValueForKey(m, "put")
	if v3 != nil {
		var err error
		x.Put, err = NewOperation(v3, helpers.NewContext("put", context))
		if err != nil {
			return nil, helpers.ExtendError("put", err)
		}
	}
	// Operation post = 4;
	v4 := helpers.MapValueForKey(m, "post")
	if v4 != nil {
		var err error
		x.Post, err = NewOperation(v4, helpers.NewContext("post", context))
		if err != nil {
			return nil, helpers.ExtendError("post", err)
		}
	}
	// Operation delete = 5;
	v5 := helpers.MapValueForKey(m, "delete")
	if v5 != nil {
		var err error
		x.Delete, err = NewOperation(v5, helpers.NewContext("delete", context))
		if err != nil {
			return nil, helpers.ExtendError("delete", err)
		}
	}
	// Operation options = 6;
	v6 := helpers.MapValueForKey(m, "options")
	if v6 != nil {
		var err error
		x.Options, err = NewOperation(v6, helpers.NewContext("options", context))
		if err != nil {
			return nil, helpers.ExtendError("options", err)
		}
	}
	// Operation head = 7;
	v7 := helpers.MapValueForKey(m, "head")
	if v7 != nil {
		var err error
		x.Head, err = NewOperation(v7, helpers.NewContext("head", context))
		if err != nil {
			return nil, helpers.ExtendError("head", err)
		}
	}
	// Operation patch = 8;
	v8 := helpers.MapValueForKey(m, "patch")
	if v8 != nil {
		var err error
		x.Patch, err = NewOperation(v8, helpers.NewContext("patch", context))
		if err != nil {
			return nil, helpers.ExtendError("patch", err)
		}
	}
	// repeated ParametersItem parameters = 9;
	v9 := helpers.MapValueForKey(m, "parameters")
	if v9 != nil {
		// repeated class ParametersItem
		x.Parameters = make([]*ParametersItem, 0)
		a, ok := v9.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewParametersItem(item, helpers.NewContext("parameters", context))
				if err != nil {
					return nil, err
				}
				x.Parameters = append(x.Parameters, y)
			}
		}
	}
	// repeated NamedAny vendor_extension = 10;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewPathParameterSubSchema(in interface{}, context *helpers.Context) (*PathParameterSubSchema, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for PathParameterSubSchema section: %+v", in))
	}
	requiredKeys := []string{"required"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("PathParameterSubSchema does not contain all required properties ('required')")
	}
	allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("PathParameterSubSchema includes properties not in ('collectionFormat','default','description','enum','exclusiveMaximum','exclusiveMinimum','format','in','items','maxItems','maxLength','maximum','minItems','minLength','minimum','multipleOf','name','pattern','required','type','uniqueItems') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &PathParameterSubSchema{}
	// bool required = 1;
	v1 := helpers.MapValueForKey(m, "required")
	if v1 != nil {
		x.Required = v1.(bool)
	}
	// string in = 2;
	v2 := helpers.MapValueForKey(m, "in")
	if v2 != nil {
		x.In = v2.(string)
	}
	// string description = 3;
	v3 := helpers.MapValueForKey(m, "description")
	if v3 != nil {
		x.Description = v3.(string)
	}
	// string name = 4;
	v4 := helpers.MapValueForKey(m, "name")
	if v4 != nil {
		x.Name = v4.(string)
	}
	// string type = 5;
	v5 := helpers.MapValueForKey(m, "type")
	if v5 != nil {
		x.Type = v5.(string)
	}
	// string format = 6;
	v6 := helpers.MapValueForKey(m, "format")
	if v6 != nil {
		x.Format = v6.(string)
	}
	// PrimitivesItems items = 7;
	v7 := helpers.MapValueForKey(m, "items")
	if v7 != nil {
		var err error
		x.Items, err = NewPrimitivesItems(v7, helpers.NewContext("items", context))
		if err != nil {
			return nil, helpers.ExtendError("items", err)
		}
	}
	// string collection_format = 8;
	v8 := helpers.MapValueForKey(m, "collectionFormat")
	if v8 != nil {
		x.CollectionFormat = v8.(string)
	}
	// Any default = 9;
	v9 := helpers.MapValueForKey(m, "default")
	if v9 != nil {
		var err error
		x.Default, err = NewAny(v9, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// float maximum = 10;
	v10 := helpers.MapValueForKey(m, "maximum")
	if v10 != nil {
		x.Maximum = v10.(float64)
	}
	// bool exclusive_maximum = 11;
	v11 := helpers.MapValueForKey(m, "exclusiveMaximum")
	if v11 != nil {
		x.ExclusiveMaximum = v11.(bool)
	}
	// float minimum = 12;
	v12 := helpers.MapValueForKey(m, "minimum")
	if v12 != nil {
		x.Minimum = v12.(float64)
	}
	// bool exclusive_minimum = 13;
	v13 := helpers.MapValueForKey(m, "exclusiveMinimum")
	if v13 != nil {
		x.ExclusiveMinimum = v13.(bool)
	}
	// int64 max_length = 14;
	v14 := helpers.MapValueForKey(m, "maxLength")
	if v14 != nil {
		x.MaxLength = v14.(int64)
	}
	// int64 min_length = 15;
	v15 := helpers.MapValueForKey(m, "minLength")
	if v15 != nil {
		x.MinLength = v15.(int64)
	}
	// string pattern = 16;
	v16 := helpers.MapValueForKey(m, "pattern")
	if v16 != nil {
		x.Pattern = v16.(string)
	}
	// int64 max_items = 17;
	v17 := helpers.MapValueForKey(m, "maxItems")
	if v17 != nil {
		x.MaxItems = v17.(int64)
	}
	// int64 min_items = 18;
	v18 := helpers.MapValueForKey(m, "minItems")
	if v18 != nil {
		x.MinItems = v18.(int64)
	}
	// bool unique_items = 19;
	v19 := helpers.MapValueForKey(m, "uniqueItems")
	if v19 != nil {
		x.UniqueItems = v19.(bool)
	}
	// repeated Any enum = 20;
	v20 := helpers.MapValueForKey(m, "enum")
	if v20 != nil {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := v20.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewAny(item, helpers.NewContext("enum", context))
				if err != nil {
					return nil, err
				}
				x.Enum = append(x.Enum, y)
			}
		}
	}
	// float multiple_of = 21;
	v21 := helpers.MapValueForKey(m, "multipleOf")
	if v21 != nil {
		x.MultipleOf = v21.(float64)
	}
	// repeated NamedAny vendor_extension = 22;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewPaths(in interface{}, context *helpers.Context) (*Paths, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Paths section: %+v", in))
	}
	allowedKeys := []string{}
	allowedPatterns := []string{"^x-", "^/"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Paths includes properties not in () or ('^x-','^/'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Paths{}
	// repeated NamedAny vendor_extension = 1;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	// repeated NamedPathItem path = 2;
	// MAP: PathItem ^/
	x.Path = make([]*NamedPathItem, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^/", k) {
			pair := &NamedPathItem{}
			pair.Name = k
			var err error
			pair.Value, err = NewPathItem(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.Path = append(x.Path, pair)
		}
	}
	return x, nil
}

func NewPrimitivesItems(in interface{}, context *helpers.Context) (*PrimitivesItems, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for PrimitivesItems section: %+v", in))
	}
	allowedKeys := []string{"collectionFormat", "default", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "pattern", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("PrimitivesItems includes properties not in ('collectionFormat','default','enum','exclusiveMaximum','exclusiveMinimum','format','items','maxItems','maxLength','maximum','minItems','minLength','minimum','multipleOf','pattern','type','uniqueItems') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &PrimitivesItems{}
	// string type = 1;
	v1 := helpers.MapValueForKey(m, "type")
	if v1 != nil {
		x.Type = v1.(string)
	}
	// string format = 2;
	v2 := helpers.MapValueForKey(m, "format")
	if v2 != nil {
		x.Format = v2.(string)
	}
	// PrimitivesItems items = 3;
	v3 := helpers.MapValueForKey(m, "items")
	if v3 != nil {
		var err error
		x.Items, err = NewPrimitivesItems(v3, helpers.NewContext("items", context))
		if err != nil {
			return nil, helpers.ExtendError("items", err)
		}
	}
	// string collection_format = 4;
	v4 := helpers.MapValueForKey(m, "collectionFormat")
	if v4 != nil {
		x.CollectionFormat = v4.(string)
	}
	// Any default = 5;
	v5 := helpers.MapValueForKey(m, "default")
	if v5 != nil {
		var err error
		x.Default, err = NewAny(v5, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// float maximum = 6;
	v6 := helpers.MapValueForKey(m, "maximum")
	if v6 != nil {
		x.Maximum = v6.(float64)
	}
	// bool exclusive_maximum = 7;
	v7 := helpers.MapValueForKey(m, "exclusiveMaximum")
	if v7 != nil {
		x.ExclusiveMaximum = v7.(bool)
	}
	// float minimum = 8;
	v8 := helpers.MapValueForKey(m, "minimum")
	if v8 != nil {
		x.Minimum = v8.(float64)
	}
	// bool exclusive_minimum = 9;
	v9 := helpers.MapValueForKey(m, "exclusiveMinimum")
	if v9 != nil {
		x.ExclusiveMinimum = v9.(bool)
	}
	// int64 max_length = 10;
	v10 := helpers.MapValueForKey(m, "maxLength")
	if v10 != nil {
		x.MaxLength = v10.(int64)
	}
	// int64 min_length = 11;
	v11 := helpers.MapValueForKey(m, "minLength")
	if v11 != nil {
		x.MinLength = v11.(int64)
	}
	// string pattern = 12;
	v12 := helpers.MapValueForKey(m, "pattern")
	if v12 != nil {
		x.Pattern = v12.(string)
	}
	// int64 max_items = 13;
	v13 := helpers.MapValueForKey(m, "maxItems")
	if v13 != nil {
		x.MaxItems = v13.(int64)
	}
	// int64 min_items = 14;
	v14 := helpers.MapValueForKey(m, "minItems")
	if v14 != nil {
		x.MinItems = v14.(int64)
	}
	// bool unique_items = 15;
	v15 := helpers.MapValueForKey(m, "uniqueItems")
	if v15 != nil {
		x.UniqueItems = v15.(bool)
	}
	// repeated Any enum = 16;
	v16 := helpers.MapValueForKey(m, "enum")
	if v16 != nil {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := v16.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewAny(item, helpers.NewContext("enum", context))
				if err != nil {
					return nil, err
				}
				x.Enum = append(x.Enum, y)
			}
		}
	}
	// float multiple_of = 17;
	v17 := helpers.MapValueForKey(m, "multipleOf")
	if v17 != nil {
		x.MultipleOf = v17.(float64)
	}
	// repeated NamedAny vendor_extension = 18;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewProperties(in interface{}, context *helpers.Context) (*Properties, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Properties section: %+v", in))
	}
	x := &Properties{}
	// repeated NamedSchema additional_properties = 1;
	// MAP: Schema
	x.AdditionalProperties = make([]*NamedSchema, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedSchema{}
		pair.Name = k
		var err error
		pair.Value, err = NewSchema(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewQueryParameterSubSchema(in interface{}, context *helpers.Context) (*QueryParameterSubSchema, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for QueryParameterSubSchema section: %+v", in))
	}
	allowedKeys := []string{"allowEmptyValue", "collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("QueryParameterSubSchema includes properties not in ('allowEmptyValue','collectionFormat','default','description','enum','exclusiveMaximum','exclusiveMinimum','format','in','items','maxItems','maxLength','maximum','minItems','minLength','minimum','multipleOf','name','pattern','required','type','uniqueItems') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &QueryParameterSubSchema{}
	// bool required = 1;
	v1 := helpers.MapValueForKey(m, "required")
	if v1 != nil {
		x.Required = v1.(bool)
	}
	// string in = 2;
	v2 := helpers.MapValueForKey(m, "in")
	if v2 != nil {
		x.In = v2.(string)
	}
	// string description = 3;
	v3 := helpers.MapValueForKey(m, "description")
	if v3 != nil {
		x.Description = v3.(string)
	}
	// string name = 4;
	v4 := helpers.MapValueForKey(m, "name")
	if v4 != nil {
		x.Name = v4.(string)
	}
	// bool allow_empty_value = 5;
	v5 := helpers.MapValueForKey(m, "allowEmptyValue")
	if v5 != nil {
		x.AllowEmptyValue = v5.(bool)
	}
	// string type = 6;
	v6 := helpers.MapValueForKey(m, "type")
	if v6 != nil {
		x.Type = v6.(string)
	}
	// string format = 7;
	v7 := helpers.MapValueForKey(m, "format")
	if v7 != nil {
		x.Format = v7.(string)
	}
	// PrimitivesItems items = 8;
	v8 := helpers.MapValueForKey(m, "items")
	if v8 != nil {
		var err error
		x.Items, err = NewPrimitivesItems(v8, helpers.NewContext("items", context))
		if err != nil {
			return nil, helpers.ExtendError("items", err)
		}
	}
	// string collection_format = 9;
	v9 := helpers.MapValueForKey(m, "collectionFormat")
	if v9 != nil {
		x.CollectionFormat = v9.(string)
	}
	// Any default = 10;
	v10 := helpers.MapValueForKey(m, "default")
	if v10 != nil {
		var err error
		x.Default, err = NewAny(v10, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// float maximum = 11;
	v11 := helpers.MapValueForKey(m, "maximum")
	if v11 != nil {
		x.Maximum = v11.(float64)
	}
	// bool exclusive_maximum = 12;
	v12 := helpers.MapValueForKey(m, "exclusiveMaximum")
	if v12 != nil {
		x.ExclusiveMaximum = v12.(bool)
	}
	// float minimum = 13;
	v13 := helpers.MapValueForKey(m, "minimum")
	if v13 != nil {
		x.Minimum = v13.(float64)
	}
	// bool exclusive_minimum = 14;
	v14 := helpers.MapValueForKey(m, "exclusiveMinimum")
	if v14 != nil {
		x.ExclusiveMinimum = v14.(bool)
	}
	// int64 max_length = 15;
	v15 := helpers.MapValueForKey(m, "maxLength")
	if v15 != nil {
		x.MaxLength = v15.(int64)
	}
	// int64 min_length = 16;
	v16 := helpers.MapValueForKey(m, "minLength")
	if v16 != nil {
		x.MinLength = v16.(int64)
	}
	// string pattern = 17;
	v17 := helpers.MapValueForKey(m, "pattern")
	if v17 != nil {
		x.Pattern = v17.(string)
	}
	// int64 max_items = 18;
	v18 := helpers.MapValueForKey(m, "maxItems")
	if v18 != nil {
		x.MaxItems = v18.(int64)
	}
	// int64 min_items = 19;
	v19 := helpers.MapValueForKey(m, "minItems")
	if v19 != nil {
		x.MinItems = v19.(int64)
	}
	// bool unique_items = 20;
	v20 := helpers.MapValueForKey(m, "uniqueItems")
	if v20 != nil {
		x.UniqueItems = v20.(bool)
	}
	// repeated Any enum = 21;
	v21 := helpers.MapValueForKey(m, "enum")
	if v21 != nil {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := v21.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewAny(item, helpers.NewContext("enum", context))
				if err != nil {
					return nil, err
				}
				x.Enum = append(x.Enum, y)
			}
		}
	}
	// float multiple_of = 22;
	v22 := helpers.MapValueForKey(m, "multipleOf")
	if v22 != nil {
		x.MultipleOf = v22.(float64)
	}
	// repeated NamedAny vendor_extension = 23;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewResponse(in interface{}, context *helpers.Context) (*Response, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Response section: %+v", in))
	}
	requiredKeys := []string{"description"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Response does not contain all required properties ('description')")
	}
	allowedKeys := []string{"description", "examples", "headers", "schema"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Response includes properties not in ('description','examples','headers','schema') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Response{}
	// string description = 1;
	v1 := helpers.MapValueForKey(m, "description")
	if v1 != nil {
		x.Description = v1.(string)
	}
	// SchemaItem schema = 2;
	v2 := helpers.MapValueForKey(m, "schema")
	if v2 != nil {
		var err error
		x.Schema, err = NewSchemaItem(v2, helpers.NewContext("schema", context))
		if err != nil {
			return nil, helpers.ExtendError("schema", err)
		}
	}
	// Headers headers = 3;
	v3 := helpers.MapValueForKey(m, "headers")
	if v3 != nil {
		var err error
		x.Headers, err = NewHeaders(v3, helpers.NewContext("headers", context))
		if err != nil {
			return nil, helpers.ExtendError("headers", err)
		}
	}
	// Examples examples = 4;
	v4 := helpers.MapValueForKey(m, "examples")
	if v4 != nil {
		var err error
		x.Examples, err = NewExamples(v4, helpers.NewContext("examples", context))
		if err != nil {
			return nil, helpers.ExtendError("examples", err)
		}
	}
	// repeated NamedAny vendor_extension = 5;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewResponseDefinitions(in interface{}, context *helpers.Context) (*ResponseDefinitions, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for ResponseDefinitions section: %+v", in))
	}
	x := &ResponseDefinitions{}
	// repeated NamedResponse additional_properties = 1;
	// MAP: Response
	x.AdditionalProperties = make([]*NamedResponse, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedResponse{}
		pair.Name = k
		var err error
		pair.Value, err = NewResponse(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewResponseValue(in interface{}, context *helpers.Context) (*ResponseValue, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for ResponseValue section: %+v", in))
	}
	x := &ResponseValue{}
	// Response response = 1;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewResponse(m, helpers.NewContext("response", context))
		if t != nil {
			x.Oneof = &ResponseValue_Response{Response: t}
		}
	}
	// JsonReference json_reference = 2;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewJsonReference(m, helpers.NewContext("jsonReference", context))
		if t != nil {
			x.Oneof = &ResponseValue_JsonReference{JsonReference: t}
		}
	}
	return x, nil
}

func NewResponses(in interface{}, context *helpers.Context) (*Responses, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Responses section: %+v", in))
	}
	allowedKeys := []string{}
	allowedPatterns := []string{"^([0-9]{3})$|^(default)$", "^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Responses includes properties not in () or ('^([0-9]{3})$|^(default)$','^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Responses{}
	// repeated NamedResponseValue response_code = 1;
	// MAP: ResponseValue ^([0-9]{3})$|^(default)$
	x.ResponseCode = make([]*NamedResponseValue, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^([0-9]{3})$|^(default)$", k) {
			pair := &NamedResponseValue{}
			pair.Name = k
			var err error
			pair.Value, err = NewResponseValue(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.ResponseCode = append(x.ResponseCode, pair)
		}
	}
	// repeated NamedAny vendor_extension = 2;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewSchema(in interface{}, context *helpers.Context) (*Schema, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Schema section: %+v", in))
	}
	allowedKeys := []string{"$ref", "additionalProperties", "allOf", "default", "description", "discriminator", "enum", "example", "exclusiveMaximum", "exclusiveMinimum", "externalDocs", "format", "items", "maxItems", "maxLength", "maxProperties", "maximum", "minItems", "minLength", "minProperties", "minimum", "multipleOf", "pattern", "properties", "readOnly", "required", "title", "type", "uniqueItems", "xml"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Schema includes properties not in ('$ref','additionalProperties','allOf','default','description','discriminator','enum','example','exclusiveMaximum','exclusiveMinimum','externalDocs','format','items','maxItems','maxLength','maxProperties','maximum','minItems','minLength','minProperties','minimum','multipleOf','pattern','properties','readOnly','required','title','type','uniqueItems','xml') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Schema{}
	// string _ref = 1;
	v1 := helpers.MapValueForKey(m, "$ref")
	if v1 != nil {
		x.XRef = v1.(string)
	}
	// string format = 2;
	v2 := helpers.MapValueForKey(m, "format")
	if v2 != nil {
		x.Format = v2.(string)
	}
	// string title = 3;
	v3 := helpers.MapValueForKey(m, "title")
	if v3 != nil {
		x.Title = v3.(string)
	}
	// string description = 4;
	v4 := helpers.MapValueForKey(m, "description")
	if v4 != nil {
		x.Description = v4.(string)
	}
	// Any default = 5;
	v5 := helpers.MapValueForKey(m, "default")
	if v5 != nil {
		var err error
		x.Default, err = NewAny(v5, helpers.NewContext("default", context))
		if err != nil {
			return nil, helpers.ExtendError("default", err)
		}
	}
	// float multiple_of = 6;
	v6 := helpers.MapValueForKey(m, "multipleOf")
	if v6 != nil {
		x.MultipleOf = v6.(float64)
	}
	// float maximum = 7;
	v7 := helpers.MapValueForKey(m, "maximum")
	if v7 != nil {
		x.Maximum = v7.(float64)
	}
	// bool exclusive_maximum = 8;
	v8 := helpers.MapValueForKey(m, "exclusiveMaximum")
	if v8 != nil {
		x.ExclusiveMaximum = v8.(bool)
	}
	// float minimum = 9;
	v9 := helpers.MapValueForKey(m, "minimum")
	if v9 != nil {
		x.Minimum = v9.(float64)
	}
	// bool exclusive_minimum = 10;
	v10 := helpers.MapValueForKey(m, "exclusiveMinimum")
	if v10 != nil {
		x.ExclusiveMinimum = v10.(bool)
	}
	// int64 max_length = 11;
	v11 := helpers.MapValueForKey(m, "maxLength")
	if v11 != nil {
		x.MaxLength = v11.(int64)
	}
	// int64 min_length = 12;
	v12 := helpers.MapValueForKey(m, "minLength")
	if v12 != nil {
		x.MinLength = v12.(int64)
	}
	// string pattern = 13;
	v13 := helpers.MapValueForKey(m, "pattern")
	if v13 != nil {
		x.Pattern = v13.(string)
	}
	// int64 max_items = 14;
	v14 := helpers.MapValueForKey(m, "maxItems")
	if v14 != nil {
		x.MaxItems = v14.(int64)
	}
	// int64 min_items = 15;
	v15 := helpers.MapValueForKey(m, "minItems")
	if v15 != nil {
		x.MinItems = v15.(int64)
	}
	// bool unique_items = 16;
	v16 := helpers.MapValueForKey(m, "uniqueItems")
	if v16 != nil {
		x.UniqueItems = v16.(bool)
	}
	// int64 max_properties = 17;
	v17 := helpers.MapValueForKey(m, "maxProperties")
	if v17 != nil {
		x.MaxProperties = v17.(int64)
	}
	// int64 min_properties = 18;
	v18 := helpers.MapValueForKey(m, "minProperties")
	if v18 != nil {
		x.MinProperties = v18.(int64)
	}
	// repeated string required = 19;
	v19 := helpers.MapValueForKey(m, "required")
	if v19 != nil {
		v, ok := v19.([]interface{})
		if ok {
			x.Required = helpers.ConvertInterfaceArrayToStringArray(v)
		} else {
			return nil, errors.New(fmt.Sprintf("unexpected value for required property: %+v", in))
		}
	}
	// repeated Any enum = 20;
	v20 := helpers.MapValueForKey(m, "enum")
	if v20 != nil {
		// repeated class Any
		x.Enum = make([]*Any, 0)
		a, ok := v20.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewAny(item, helpers.NewContext("enum", context))
				if err != nil {
					return nil, err
				}
				x.Enum = append(x.Enum, y)
			}
		}
	}
	// AdditionalPropertiesItem additional_properties = 21;
	v21 := helpers.MapValueForKey(m, "additionalProperties")
	if v21 != nil {
		var err error
		x.AdditionalProperties, err = NewAdditionalPropertiesItem(v21, helpers.NewContext("additionalProperties", context))
		if err != nil {
			return nil, helpers.ExtendError("additionalProperties", err)
		}
	}
	// TypeItem type = 22;
	v22 := helpers.MapValueForKey(m, "type")
	if v22 != nil {
		var err error
		x.Type, err = NewTypeItem(v22, helpers.NewContext("type", context))
		if err != nil {
			return nil, helpers.ExtendError("type", err)
		}
	}
	// ItemsItem items = 23;
	v23 := helpers.MapValueForKey(m, "items")
	if v23 != nil {
		var err error
		x.Items, err = NewItemsItem(v23, helpers.NewContext("items", context))
		if err != nil {
			return nil, helpers.ExtendError("items", err)
		}
	}
	// repeated Schema all_of = 24;
	v24 := helpers.MapValueForKey(m, "allOf")
	if v24 != nil {
		// repeated class Schema
		x.AllOf = make([]*Schema, 0)
		a, ok := v24.([]interface{})
		if ok {
			for _, item := range a {
				y, err := NewSchema(item, helpers.NewContext("allOf", context))
				if err != nil {
					return nil, err
				}
				x.AllOf = append(x.AllOf, y)
			}
		}
	}
	// Properties properties = 25;
	v25 := helpers.MapValueForKey(m, "properties")
	if v25 != nil {
		var err error
		x.Properties, err = NewProperties(v25, helpers.NewContext("properties", context))
		if err != nil {
			return nil, helpers.ExtendError("properties", err)
		}
	}
	// string discriminator = 26;
	v26 := helpers.MapValueForKey(m, "discriminator")
	if v26 != nil {
		x.Discriminator = v26.(string)
	}
	// bool read_only = 27;
	v27 := helpers.MapValueForKey(m, "readOnly")
	if v27 != nil {
		x.ReadOnly = v27.(bool)
	}
	// Xml xml = 28;
	v28 := helpers.MapValueForKey(m, "xml")
	if v28 != nil {
		var err error
		x.Xml, err = NewXml(v28, helpers.NewContext("xml", context))
		if err != nil {
			return nil, helpers.ExtendError("xml", err)
		}
	}
	// ExternalDocs external_docs = 29;
	v29 := helpers.MapValueForKey(m, "externalDocs")
	if v29 != nil {
		var err error
		x.ExternalDocs, err = NewExternalDocs(v29, helpers.NewContext("externalDocs", context))
		if err != nil {
			return nil, helpers.ExtendError("externalDocs", err)
		}
	}
	// Any example = 30;
	v30 := helpers.MapValueForKey(m, "example")
	if v30 != nil {
		var err error
		x.Example, err = NewAny(v30, helpers.NewContext("example", context))
		if err != nil {
			return nil, helpers.ExtendError("example", err)
		}
	}
	// repeated NamedAny vendor_extension = 31;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewSchemaItem(in interface{}, context *helpers.Context) (*SchemaItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for SchemaItem section: %+v", in))
	}
	x := &SchemaItem{}
	// Schema schema = 1;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewSchema(m, helpers.NewContext("schema", context))
		if t != nil {
			x.Oneof = &SchemaItem_Schema{Schema: t}
		}
	}
	// FileSchema file_schema = 2;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewFileSchema(m, helpers.NewContext("fileSchema", context))
		if t != nil {
			x.Oneof = &SchemaItem_FileSchema{FileSchema: t}
		}
	}
	return x, nil
}

func NewSecurityDefinitions(in interface{}, context *helpers.Context) (*SecurityDefinitions, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for SecurityDefinitions section: %+v", in))
	}
	x := &SecurityDefinitions{}
	// repeated NamedSecurityDefinitionsItem additional_properties = 1;
	// MAP: SecurityDefinitionsItem
	x.AdditionalProperties = make([]*NamedSecurityDefinitionsItem, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedSecurityDefinitionsItem{}
		pair.Name = k
		var err error
		pair.Value, err = NewSecurityDefinitionsItem(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewSecurityDefinitionsItem(in interface{}, context *helpers.Context) (*SecurityDefinitionsItem, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for SecurityDefinitionsItem section: %+v", in))
	}
	x := &SecurityDefinitionsItem{}
	// BasicAuthenticationSecurity basic_authentication_security = 1;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewBasicAuthenticationSecurity(m, helpers.NewContext("basicAuthenticationSecurity", context))
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_BasicAuthenticationSecurity{BasicAuthenticationSecurity: t}
		}
	}
	// ApiKeySecurity api_key_security = 2;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewApiKeySecurity(m, helpers.NewContext("apiKeySecurity", context))
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_ApiKeySecurity{ApiKeySecurity: t}
		}
	}
	// Oauth2ImplicitSecurity oauth2_implicit_security = 3;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewOauth2ImplicitSecurity(m, helpers.NewContext("oauth2ImplicitSecurity", context))
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2ImplicitSecurity{Oauth2ImplicitSecurity: t}
		}
	}
	// Oauth2PasswordSecurity oauth2_password_security = 4;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewOauth2PasswordSecurity(m, helpers.NewContext("oauth2PasswordSecurity", context))
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2PasswordSecurity{Oauth2PasswordSecurity: t}
		}
	}
	// Oauth2ApplicationSecurity oauth2_application_security = 5;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewOauth2ApplicationSecurity(m, helpers.NewContext("oauth2ApplicationSecurity", context))
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2ApplicationSecurity{Oauth2ApplicationSecurity: t}
		}
	}
	// Oauth2AccessCodeSecurity oauth2_access_code_security = 6;
	{
		// errors are ok here, they mean we just don't have the right subtype
		t, _ := NewOauth2AccessCodeSecurity(m, helpers.NewContext("oauth2AccessCodeSecurity", context))
		if t != nil {
			x.Oneof = &SecurityDefinitionsItem_Oauth2AccessCodeSecurity{Oauth2AccessCodeSecurity: t}
		}
	}
	return x, nil
}

func NewSecurityRequirement(in interface{}, context *helpers.Context) (*SecurityRequirement, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for SecurityRequirement section: %+v", in))
	}
	x := &SecurityRequirement{}
	// repeated NamedStringArray additional_properties = 1;
	// MAP: StringArray
	x.AdditionalProperties = make([]*NamedStringArray, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedStringArray{}
		pair.Name = k
		var err error
		pair.Value, err = NewStringArray(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewStringArray(in interface{}, context *helpers.Context) (*StringArray, error) {
	a, ok := in.([]interface{})
	if ok {
		x := &StringArray{}
		x.Value = make([]string, 0)
		for _, s := range a {
			x.Value = append(x.Value, s.(string))
		}
		return x, nil
	} else {
		return nil, nil
	}
}

func NewTag(in interface{}, context *helpers.Context) (*Tag, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Tag section: %+v", in))
	}
	requiredKeys := []string{"name"}
	if !helpers.MapContainsAllKeys(m, requiredKeys) {
		return nil, errors.New("Tag does not contain all required properties ('name')")
	}
	allowedKeys := []string{"description", "externalDocs", "name"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Tag includes properties not in ('description','externalDocs','name') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Tag{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// string description = 2;
	v2 := helpers.MapValueForKey(m, "description")
	if v2 != nil {
		x.Description = v2.(string)
	}
	// ExternalDocs external_docs = 3;
	v3 := helpers.MapValueForKey(m, "externalDocs")
	if v3 != nil {
		var err error
		x.ExternalDocs, err = NewExternalDocs(v3, helpers.NewContext("externalDocs", context))
		if err != nil {
			return nil, helpers.ExtendError("externalDocs", err)
		}
	}
	// repeated NamedAny vendor_extension = 4;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func NewTypeItem(in interface{}, context *helpers.Context) (*TypeItem, error) {
	value, ok := in.(string)
	x := &TypeItem{}
	if ok {
		x.Value = make([]string, 0)
		x.Value = append(x.Value, value)
	} else {
		return nil, errors.New(fmt.Sprintf("unexpected value for string array: %+v", in))
	}
	return x, nil
}

func NewVendorExtension(in interface{}, context *helpers.Context) (*VendorExtension, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for VendorExtension section: %+v", in))
	}
	x := &VendorExtension{}
	// repeated NamedAny additional_properties = 1;
	// MAP: Any
	x.AdditionalProperties = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		pair := &NamedAny{}
		pair.Name = k
		var err error
		pair.Value, err = NewAny(v, helpers.NewContext(k, context))
		if err != nil {
			return nil, err
		}
		x.AdditionalProperties = append(x.AdditionalProperties, pair)
	}
	return x, nil
}

func NewXml(in interface{}, context *helpers.Context) (*Xml, error) {
	m, ok := helpers.UnpackMap(in)
	if !ok {
		return nil, errors.New(fmt.Sprintf("unexpected value for Xml section: %+v", in))
	}
	allowedKeys := []string{"attribute", "name", "namespace", "prefix", "wrapped"}
	allowedPatterns := []string{"^x-"}
	if !helpers.MapContainsOnlyKeysAndPatterns(m, allowedKeys, allowedPatterns) {
		return nil, errors.New(
			fmt.Sprintf("Xml includes properties not in ('attribute','name','namespace','prefix','wrapped') or ('^x-'): %+v",
				helpers.SortedKeysForMap(m)))
	}
	x := &Xml{}
	// string name = 1;
	v1 := helpers.MapValueForKey(m, "name")
	if v1 != nil {
		x.Name = v1.(string)
	}
	// string namespace = 2;
	v2 := helpers.MapValueForKey(m, "namespace")
	if v2 != nil {
		x.Namespace = v2.(string)
	}
	// string prefix = 3;
	v3 := helpers.MapValueForKey(m, "prefix")
	if v3 != nil {
		x.Prefix = v3.(string)
	}
	// bool attribute = 4;
	v4 := helpers.MapValueForKey(m, "attribute")
	if v4 != nil {
		x.Attribute = v4.(bool)
	}
	// bool wrapped = 5;
	v5 := helpers.MapValueForKey(m, "wrapped")
	if v5 != nil {
		x.Wrapped = v5.(bool)
	}
	// repeated NamedAny vendor_extension = 6;
	// MAP: Any ^x-
	x.VendorExtension = make([]*NamedAny, 0)
	for _, item := range m {
		k := item.Key.(string)
		v := item.Value
		if helpers.PatternMatches("^x-", k) {
			pair := &NamedAny{}
			pair.Name = k
			var err error
			pair.Value, err = NewAny(v, helpers.NewContext(k, context))
			if err != nil {
				return nil, err
			}
			x.VendorExtension = append(x.VendorExtension, pair)
		}
	}
	return x, nil
}

func (m *AdditionalPropertiesItem) ResolveReferences(root string) (interface{}, error) {
	{
		p, ok := m.Oneof.(*AdditionalPropertiesItem_Schema)
		if ok {
			p.Schema.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Any) ResolveReferences(root string) (interface{}, error) {
	return nil, nil
}

func (m *ApiKeySecurity) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *BasicAuthenticationSecurity) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *BodyParameter) ResolveReferences(root string) (interface{}, error) {
	if m.Schema != nil {
		m.Schema.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Contact) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Default) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Definitions) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Document) ResolveReferences(root string) (interface{}, error) {
	if m.Info != nil {
		m.Info.ResolveReferences(root)
	}
	if m.Paths != nil {
		m.Paths.ResolveReferences(root)
	}
	if m.Definitions != nil {
		m.Definitions.ResolveReferences(root)
	}
	if m.Parameters != nil {
		m.Parameters.ResolveReferences(root)
	}
	if m.Responses != nil {
		m.Responses.ResolveReferences(root)
	}
	for _, item := range m.Security {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	if m.SecurityDefinitions != nil {
		m.SecurityDefinitions.ResolveReferences(root)
	}
	for _, item := range m.Tags {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	if m.ExternalDocs != nil {
		m.ExternalDocs.ResolveReferences(root)
	}
	return nil, nil
}

func (m *Examples) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *ExternalDocs) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *FileSchema) ResolveReferences(root string) (interface{}, error) {
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	if m.ExternalDocs != nil {
		m.ExternalDocs.ResolveReferences(root)
	}
	if m.Example != nil {
		m.Example.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *FormDataParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
	if m.Items != nil {
		m.Items.ResolveReferences(root)
	}
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	for _, item := range m.Enum {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Header) ResolveReferences(root string) (interface{}, error) {
	if m.Items != nil {
		m.Items.ResolveReferences(root)
	}
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	for _, item := range m.Enum {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *HeaderParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
	if m.Items != nil {
		m.Items.ResolveReferences(root)
	}
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	for _, item := range m.Enum {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Headers) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Info) ResolveReferences(root string) (interface{}, error) {
	if m.Contact != nil {
		m.Contact.ResolveReferences(root)
	}
	if m.License != nil {
		m.License.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *ItemsItem) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.Schema {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *JsonReference) ResolveReferences(root string) (interface{}, error) {
	if m.XRef != "" {
		info := helpers.ReadInfoForRef(root, m.XRef)
		return info, nil
		return info, nil
	}
	return nil, nil
}

func (m *License) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *NamedAny) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedHeader) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedParameter) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedPathItem) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedResponse) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedResponseValue) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedSchema) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedSecurityDefinitionsItem) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NamedString) ResolveReferences(root string) (interface{}, error) {
	return nil, nil
}

func (m *NamedStringArray) ResolveReferences(root string) (interface{}, error) {
	if m.Value != nil {
		m.Value.ResolveReferences(root)
	}
	return nil, nil
}

func (m *NonBodyParameter) ResolveReferences(root string) (interface{}, error) {
	{
		p, ok := m.Oneof.(*NonBodyParameter_HeaderParameterSubSchema)
		if ok {
			p.HeaderParameterSubSchema.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*NonBodyParameter_FormDataParameterSubSchema)
		if ok {
			p.FormDataParameterSubSchema.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*NonBodyParameter_QueryParameterSubSchema)
		if ok {
			p.QueryParameterSubSchema.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*NonBodyParameter_PathParameterSubSchema)
		if ok {
			p.PathParameterSubSchema.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Oauth2AccessCodeSecurity) ResolveReferences(root string) (interface{}, error) {
	if m.Scopes != nil {
		m.Scopes.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Oauth2ApplicationSecurity) ResolveReferences(root string) (interface{}, error) {
	if m.Scopes != nil {
		m.Scopes.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Oauth2ImplicitSecurity) ResolveReferences(root string) (interface{}, error) {
	if m.Scopes != nil {
		m.Scopes.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Oauth2PasswordSecurity) ResolveReferences(root string) (interface{}, error) {
	if m.Scopes != nil {
		m.Scopes.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Oauth2Scopes) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Operation) ResolveReferences(root string) (interface{}, error) {
	if m.ExternalDocs != nil {
		m.ExternalDocs.ResolveReferences(root)
	}
	for _, item := range m.Parameters {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	if m.Responses != nil {
		m.Responses.ResolveReferences(root)
	}
	for _, item := range m.Security {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Parameter) ResolveReferences(root string) (interface{}, error) {
	{
		p, ok := m.Oneof.(*Parameter_BodyParameter)
		if ok {
			p.BodyParameter.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*Parameter_NonBodyParameter)
		if ok {
			p.NonBodyParameter.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *ParameterDefinitions) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *ParametersItem) ResolveReferences(root string) (interface{}, error) {
	{
		p, ok := m.Oneof.(*ParametersItem_Parameter)
		if ok {
			p.Parameter.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*ParametersItem_JsonReference)
		if ok {
			info, err := p.JsonReference.ResolveReferences(root)
			if err != nil {
				return nil, err
			} else if info != nil {
				n, err := NewParametersItem(info, nil)
				if err != nil {
					return nil, err
				} else if n != nil {
					*m = *n
					return nil, nil
				}
			}
		}
	}
	return nil, nil
}

func (m *PathItem) ResolveReferences(root string) (interface{}, error) {
	if m.XRef != "" {
		info := helpers.ReadInfoForRef(root, m.XRef)
		if info != nil {
			replacement, _ := NewPathItem(info, nil)
			*m = *replacement
			return m.ResolveReferences(root)
		}
		return info, nil
	}
	if m.Get != nil {
		m.Get.ResolveReferences(root)
	}
	if m.Put != nil {
		m.Put.ResolveReferences(root)
	}
	if m.Post != nil {
		m.Post.ResolveReferences(root)
	}
	if m.Delete != nil {
		m.Delete.ResolveReferences(root)
	}
	if m.Options != nil {
		m.Options.ResolveReferences(root)
	}
	if m.Head != nil {
		m.Head.ResolveReferences(root)
	}
	if m.Patch != nil {
		m.Patch.ResolveReferences(root)
	}
	for _, item := range m.Parameters {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *PathParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
	if m.Items != nil {
		m.Items.ResolveReferences(root)
	}
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	for _, item := range m.Enum {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Paths) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.Path {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *PrimitivesItems) ResolveReferences(root string) (interface{}, error) {
	if m.Items != nil {
		m.Items.ResolveReferences(root)
	}
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	for _, item := range m.Enum {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Properties) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *QueryParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
	if m.Items != nil {
		m.Items.ResolveReferences(root)
	}
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	for _, item := range m.Enum {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Response) ResolveReferences(root string) (interface{}, error) {
	if m.Schema != nil {
		m.Schema.ResolveReferences(root)
	}
	if m.Headers != nil {
		m.Headers.ResolveReferences(root)
	}
	if m.Examples != nil {
		m.Examples.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *ResponseDefinitions) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *ResponseValue) ResolveReferences(root string) (interface{}, error) {
	{
		p, ok := m.Oneof.(*ResponseValue_Response)
		if ok {
			p.Response.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*ResponseValue_JsonReference)
		if ok {
			info, err := p.JsonReference.ResolveReferences(root)
			if err != nil {
				return nil, err
			} else if info != nil {
				n, err := NewResponseValue(info, nil)
				if err != nil {
					return nil, err
				} else if n != nil {
					*m = *n
					return nil, nil
				}
			}
		}
	}
	return nil, nil
}

func (m *Responses) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.ResponseCode {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Schema) ResolveReferences(root string) (interface{}, error) {
	if m.XRef != "" {
		info := helpers.ReadInfoForRef(root, m.XRef)
		if info != nil {
			replacement, _ := NewSchema(info, nil)
			*m = *replacement
			return m.ResolveReferences(root)
		}
		return info, nil
	}
	if m.Default != nil {
		m.Default.ResolveReferences(root)
	}
	for _, item := range m.Enum {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	if m.AdditionalProperties != nil {
		m.AdditionalProperties.ResolveReferences(root)
	}
	if m.Type != nil {
		m.Type.ResolveReferences(root)
	}
	if m.Items != nil {
		m.Items.ResolveReferences(root)
	}
	for _, item := range m.AllOf {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	if m.Properties != nil {
		m.Properties.ResolveReferences(root)
	}
	if m.Xml != nil {
		m.Xml.ResolveReferences(root)
	}
	if m.ExternalDocs != nil {
		m.ExternalDocs.ResolveReferences(root)
	}
	if m.Example != nil {
		m.Example.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *SchemaItem) ResolveReferences(root string) (interface{}, error) {
	{
		p, ok := m.Oneof.(*SchemaItem_Schema)
		if ok {
			p.Schema.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*SchemaItem_FileSchema)
		if ok {
			p.FileSchema.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *SecurityDefinitions) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *SecurityDefinitionsItem) ResolveReferences(root string) (interface{}, error) {
	{
		p, ok := m.Oneof.(*SecurityDefinitionsItem_BasicAuthenticationSecurity)
		if ok {
			p.BasicAuthenticationSecurity.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*SecurityDefinitionsItem_ApiKeySecurity)
		if ok {
			p.ApiKeySecurity.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2ImplicitSecurity)
		if ok {
			p.Oauth2ImplicitSecurity.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2PasswordSecurity)
		if ok {
			p.Oauth2PasswordSecurity.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2ApplicationSecurity)
		if ok {
			p.Oauth2ApplicationSecurity.ResolveReferences(root)
		}
	}
	{
		p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2AccessCodeSecurity)
		if ok {
			p.Oauth2AccessCodeSecurity.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *SecurityRequirement) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *StringArray) ResolveReferences(root string) (interface{}, error) {
	return nil, nil
}

func (m *Tag) ResolveReferences(root string) (interface{}, error) {
	if m.ExternalDocs != nil {
		m.ExternalDocs.ResolveReferences(root)
	}
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *TypeItem) ResolveReferences(root string) (interface{}, error) {
	return nil, nil
}

func (m *VendorExtension) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.AdditionalProperties {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}

func (m *Xml) ResolveReferences(root string) (interface{}, error) {
	for _, item := range m.VendorExtension {
		if item != nil {
			item.ResolveReferences(root)
		}
	}
	return nil, nil
}
