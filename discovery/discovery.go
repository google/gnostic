// Copyright 2020 Google LLC. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package discovery_v1

import (
	"fmt"
	"regexp"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/fern-api/protoc-gen-openapi/compiler"
)

// Version returns the package name (and OpenAPI version).
func Version() string {
	return "discovery_v1"
}

// NewAnnotations creates an object of type Annotations if possible, returning an error if not.
func NewAnnotations(in *yaml.Node, context *compiler.Context) (*Annotations, error) {
	errors := make([]error, 0)
	x := &Annotations{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"required"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// repeated string required = 1;
		v1 := compiler.MapValueForKey(m, "required")
		if v1 != nil {
			v, ok := compiler.SequenceNodeForNode(v1)
			if ok {
				x.Required = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for required: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewAny creates an object of type Any if possible, returning an error if not.
func NewAny(in *yaml.Node, context *compiler.Context) (*Any, error) {
	errors := make([]error, 0)
	x := &Any{}
	bytes := compiler.Marshal(in)
	x.Yaml = string(bytes)
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewAuth creates an object of type Auth if possible, returning an error if not.
func NewAuth(in *yaml.Node, context *compiler.Context) (*Auth, error) {
	errors := make([]error, 0)
	x := &Auth{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"oauth2"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// Oauth2 oauth2 = 1;
		v1 := compiler.MapValueForKey(m, "oauth2")
		if v1 != nil {
			var err error
			x.Oauth2, err = NewOauth2(v1, compiler.NewContext("oauth2", v1, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewDocument creates an object of type Document if possible, returning an error if not.
func NewDocument(in *yaml.Node, context *compiler.Context) (*Document, error) {
	errors := make([]error, 0)
	x := &Document{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		requiredKeys := []string{"discoveryVersion", "kind"}
		missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
		if len(missingKeys) > 0 {
			message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		allowedKeys := []string{"auth", "basePath", "baseUrl", "batchPath", "canonicalName", "description", "discoveryVersion", "documentationLink", "etag", "features", "fullyEncodeReservedExpansion", "icons", "id", "kind", "labels", "methods", "mtlsRootUrl", "name", "ownerDomain", "ownerName", "packagePath", "parameters", "protocol", "resources", "revision", "rootUrl", "schemas", "servicePath", "title", "version", "version_module"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string kind = 1;
		v1 := compiler.MapValueForKey(m, "kind")
		if v1 != nil {
			x.Kind, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for kind: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string discovery_version = 2;
		v2 := compiler.MapValueForKey(m, "discoveryVersion")
		if v2 != nil {
			x.DiscoveryVersion, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for discoveryVersion: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string id = 3;
		v3 := compiler.MapValueForKey(m, "id")
		if v3 != nil {
			x.Id, ok = compiler.StringForScalarNode(v3)
			if !ok {
				message := fmt.Sprintf("has unexpected value for id: %s", compiler.Display(v3))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string name = 4;
		v4 := compiler.MapValueForKey(m, "name")
		if v4 != nil {
			x.Name, ok = compiler.StringForScalarNode(v4)
			if !ok {
				message := fmt.Sprintf("has unexpected value for name: %s", compiler.Display(v4))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string version = 5;
		v5 := compiler.MapValueForKey(m, "version")
		if v5 != nil {
			x.Version, ok = compiler.StringForScalarNode(v5)
			if !ok {
				message := fmt.Sprintf("has unexpected value for version: %s", compiler.Display(v5))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string revision = 6;
		v6 := compiler.MapValueForKey(m, "revision")
		if v6 != nil {
			x.Revision, ok = compiler.StringForScalarNode(v6)
			if !ok {
				message := fmt.Sprintf("has unexpected value for revision: %s", compiler.Display(v6))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string title = 7;
		v7 := compiler.MapValueForKey(m, "title")
		if v7 != nil {
			x.Title, ok = compiler.StringForScalarNode(v7)
			if !ok {
				message := fmt.Sprintf("has unexpected value for title: %s", compiler.Display(v7))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string description = 8;
		v8 := compiler.MapValueForKey(m, "description")
		if v8 != nil {
			x.Description, ok = compiler.StringForScalarNode(v8)
			if !ok {
				message := fmt.Sprintf("has unexpected value for description: %s", compiler.Display(v8))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Icons icons = 9;
		v9 := compiler.MapValueForKey(m, "icons")
		if v9 != nil {
			var err error
			x.Icons, err = NewIcons(v9, compiler.NewContext("icons", v9, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// string documentation_link = 10;
		v10 := compiler.MapValueForKey(m, "documentationLink")
		if v10 != nil {
			x.DocumentationLink, ok = compiler.StringForScalarNode(v10)
			if !ok {
				message := fmt.Sprintf("has unexpected value for documentationLink: %s", compiler.Display(v10))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// repeated string labels = 11;
		v11 := compiler.MapValueForKey(m, "labels")
		if v11 != nil {
			v, ok := compiler.SequenceNodeForNode(v11)
			if ok {
				x.Labels = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for labels: %s", compiler.Display(v11))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string protocol = 12;
		v12 := compiler.MapValueForKey(m, "protocol")
		if v12 != nil {
			x.Protocol, ok = compiler.StringForScalarNode(v12)
			if !ok {
				message := fmt.Sprintf("has unexpected value for protocol: %s", compiler.Display(v12))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string base_url = 13;
		v13 := compiler.MapValueForKey(m, "baseUrl")
		if v13 != nil {
			x.BaseUrl, ok = compiler.StringForScalarNode(v13)
			if !ok {
				message := fmt.Sprintf("has unexpected value for baseUrl: %s", compiler.Display(v13))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string base_path = 14;
		v14 := compiler.MapValueForKey(m, "basePath")
		if v14 != nil {
			x.BasePath, ok = compiler.StringForScalarNode(v14)
			if !ok {
				message := fmt.Sprintf("has unexpected value for basePath: %s", compiler.Display(v14))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string root_url = 15;
		v15 := compiler.MapValueForKey(m, "rootUrl")
		if v15 != nil {
			x.RootUrl, ok = compiler.StringForScalarNode(v15)
			if !ok {
				message := fmt.Sprintf("has unexpected value for rootUrl: %s", compiler.Display(v15))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string service_path = 16;
		v16 := compiler.MapValueForKey(m, "servicePath")
		if v16 != nil {
			x.ServicePath, ok = compiler.StringForScalarNode(v16)
			if !ok {
				message := fmt.Sprintf("has unexpected value for servicePath: %s", compiler.Display(v16))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string batch_path = 17;
		v17 := compiler.MapValueForKey(m, "batchPath")
		if v17 != nil {
			x.BatchPath, ok = compiler.StringForScalarNode(v17)
			if !ok {
				message := fmt.Sprintf("has unexpected value for batchPath: %s", compiler.Display(v17))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Parameters parameters = 18;
		v18 := compiler.MapValueForKey(m, "parameters")
		if v18 != nil {
			var err error
			x.Parameters, err = NewParameters(v18, compiler.NewContext("parameters", v18, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Auth auth = 19;
		v19 := compiler.MapValueForKey(m, "auth")
		if v19 != nil {
			var err error
			x.Auth, err = NewAuth(v19, compiler.NewContext("auth", v19, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// repeated string features = 20;
		v20 := compiler.MapValueForKey(m, "features")
		if v20 != nil {
			v, ok := compiler.SequenceNodeForNode(v20)
			if ok {
				x.Features = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for features: %s", compiler.Display(v20))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Schemas schemas = 21;
		v21 := compiler.MapValueForKey(m, "schemas")
		if v21 != nil {
			var err error
			x.Schemas, err = NewSchemas(v21, compiler.NewContext("schemas", v21, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Methods methods = 22;
		v22 := compiler.MapValueForKey(m, "methods")
		if v22 != nil {
			var err error
			x.Methods, err = NewMethods(v22, compiler.NewContext("methods", v22, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Resources resources = 23;
		v23 := compiler.MapValueForKey(m, "resources")
		if v23 != nil {
			var err error
			x.Resources, err = NewResources(v23, compiler.NewContext("resources", v23, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// string etag = 24;
		v24 := compiler.MapValueForKey(m, "etag")
		if v24 != nil {
			x.Etag, ok = compiler.StringForScalarNode(v24)
			if !ok {
				message := fmt.Sprintf("has unexpected value for etag: %s", compiler.Display(v24))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string owner_domain = 25;
		v25 := compiler.MapValueForKey(m, "ownerDomain")
		if v25 != nil {
			x.OwnerDomain, ok = compiler.StringForScalarNode(v25)
			if !ok {
				message := fmt.Sprintf("has unexpected value for ownerDomain: %s", compiler.Display(v25))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string owner_name = 26;
		v26 := compiler.MapValueForKey(m, "ownerName")
		if v26 != nil {
			x.OwnerName, ok = compiler.StringForScalarNode(v26)
			if !ok {
				message := fmt.Sprintf("has unexpected value for ownerName: %s", compiler.Display(v26))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool version_module = 27;
		v27 := compiler.MapValueForKey(m, "version_module")
		if v27 != nil {
			x.VersionModule, ok = compiler.BoolForScalarNode(v27)
			if !ok {
				message := fmt.Sprintf("has unexpected value for version_module: %s", compiler.Display(v27))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string canonical_name = 28;
		v28 := compiler.MapValueForKey(m, "canonicalName")
		if v28 != nil {
			x.CanonicalName, ok = compiler.StringForScalarNode(v28)
			if !ok {
				message := fmt.Sprintf("has unexpected value for canonicalName: %s", compiler.Display(v28))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool fully_encode_reserved_expansion = 29;
		v29 := compiler.MapValueForKey(m, "fullyEncodeReservedExpansion")
		if v29 != nil {
			x.FullyEncodeReservedExpansion, ok = compiler.BoolForScalarNode(v29)
			if !ok {
				message := fmt.Sprintf("has unexpected value for fullyEncodeReservedExpansion: %s", compiler.Display(v29))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string package_path = 30;
		v30 := compiler.MapValueForKey(m, "packagePath")
		if v30 != nil {
			x.PackagePath, ok = compiler.StringForScalarNode(v30)
			if !ok {
				message := fmt.Sprintf("has unexpected value for packagePath: %s", compiler.Display(v30))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string mtls_root_url = 31;
		v31 := compiler.MapValueForKey(m, "mtlsRootUrl")
		if v31 != nil {
			x.MtlsRootUrl, ok = compiler.StringForScalarNode(v31)
			if !ok {
				message := fmt.Sprintf("has unexpected value for mtlsRootUrl: %s", compiler.Display(v31))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewIcons creates an object of type Icons if possible, returning an error if not.
func NewIcons(in *yaml.Node, context *compiler.Context) (*Icons, error) {
	errors := make([]error, 0)
	x := &Icons{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		requiredKeys := []string{"x16", "x32"}
		missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
		if len(missingKeys) > 0 {
			message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		allowedKeys := []string{"x16", "x32"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string x16 = 1;
		v1 := compiler.MapValueForKey(m, "x16")
		if v1 != nil {
			x.X16, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for x16: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string x32 = 2;
		v2 := compiler.MapValueForKey(m, "x32")
		if v2 != nil {
			x.X32, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for x32: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewMediaUpload creates an object of type MediaUpload if possible, returning an error if not.
func NewMediaUpload(in *yaml.Node, context *compiler.Context) (*MediaUpload, error) {
	errors := make([]error, 0)
	x := &MediaUpload{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"accept", "maxSize", "protocols", "supportsSubscription"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// repeated string accept = 1;
		v1 := compiler.MapValueForKey(m, "accept")
		if v1 != nil {
			v, ok := compiler.SequenceNodeForNode(v1)
			if ok {
				x.Accept = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for accept: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string max_size = 2;
		v2 := compiler.MapValueForKey(m, "maxSize")
		if v2 != nil {
			x.MaxSize, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for maxSize: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Protocols protocols = 3;
		v3 := compiler.MapValueForKey(m, "protocols")
		if v3 != nil {
			var err error
			x.Protocols, err = NewProtocols(v3, compiler.NewContext("protocols", v3, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// bool supports_subscription = 4;
		v4 := compiler.MapValueForKey(m, "supportsSubscription")
		if v4 != nil {
			x.SupportsSubscription, ok = compiler.BoolForScalarNode(v4)
			if !ok {
				message := fmt.Sprintf("has unexpected value for supportsSubscription: %s", compiler.Display(v4))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewMethod creates an object of type Method if possible, returning an error if not.
func NewMethod(in *yaml.Node, context *compiler.Context) (*Method, error) {
	errors := make([]error, 0)
	x := &Method{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"description", "etagRequired", "flatPath", "httpMethod", "id", "mediaUpload", "parameterOrder", "parameters", "path", "request", "response", "scopes", "streamingType", "supportsMediaDownload", "supportsMediaUpload", "supportsSubscription", "useMediaDownloadService"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string id = 1;
		v1 := compiler.MapValueForKey(m, "id")
		if v1 != nil {
			x.Id, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for id: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string path = 2;
		v2 := compiler.MapValueForKey(m, "path")
		if v2 != nil {
			x.Path, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for path: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string http_method = 3;
		v3 := compiler.MapValueForKey(m, "httpMethod")
		if v3 != nil {
			x.HttpMethod, ok = compiler.StringForScalarNode(v3)
			if !ok {
				message := fmt.Sprintf("has unexpected value for httpMethod: %s", compiler.Display(v3))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string description = 4;
		v4 := compiler.MapValueForKey(m, "description")
		if v4 != nil {
			x.Description, ok = compiler.StringForScalarNode(v4)
			if !ok {
				message := fmt.Sprintf("has unexpected value for description: %s", compiler.Display(v4))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Parameters parameters = 5;
		v5 := compiler.MapValueForKey(m, "parameters")
		if v5 != nil {
			var err error
			x.Parameters, err = NewParameters(v5, compiler.NewContext("parameters", v5, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// repeated string parameter_order = 6;
		v6 := compiler.MapValueForKey(m, "parameterOrder")
		if v6 != nil {
			v, ok := compiler.SequenceNodeForNode(v6)
			if ok {
				x.ParameterOrder = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for parameterOrder: %s", compiler.Display(v6))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Request request = 7;
		v7 := compiler.MapValueForKey(m, "request")
		if v7 != nil {
			var err error
			x.Request, err = NewRequest(v7, compiler.NewContext("request", v7, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Response response = 8;
		v8 := compiler.MapValueForKey(m, "response")
		if v8 != nil {
			var err error
			x.Response, err = NewResponse(v8, compiler.NewContext("response", v8, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// repeated string scopes = 9;
		v9 := compiler.MapValueForKey(m, "scopes")
		if v9 != nil {
			v, ok := compiler.SequenceNodeForNode(v9)
			if ok {
				x.Scopes = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for scopes: %s", compiler.Display(v9))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool supports_media_download = 10;
		v10 := compiler.MapValueForKey(m, "supportsMediaDownload")
		if v10 != nil {
			x.SupportsMediaDownload, ok = compiler.BoolForScalarNode(v10)
			if !ok {
				message := fmt.Sprintf("has unexpected value for supportsMediaDownload: %s", compiler.Display(v10))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool supports_media_upload = 11;
		v11 := compiler.MapValueForKey(m, "supportsMediaUpload")
		if v11 != nil {
			x.SupportsMediaUpload, ok = compiler.BoolForScalarNode(v11)
			if !ok {
				message := fmt.Sprintf("has unexpected value for supportsMediaUpload: %s", compiler.Display(v11))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool use_media_download_service = 12;
		v12 := compiler.MapValueForKey(m, "useMediaDownloadService")
		if v12 != nil {
			x.UseMediaDownloadService, ok = compiler.BoolForScalarNode(v12)
			if !ok {
				message := fmt.Sprintf("has unexpected value for useMediaDownloadService: %s", compiler.Display(v12))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// MediaUpload media_upload = 13;
		v13 := compiler.MapValueForKey(m, "mediaUpload")
		if v13 != nil {
			var err error
			x.MediaUpload, err = NewMediaUpload(v13, compiler.NewContext("mediaUpload", v13, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// bool supports_subscription = 14;
		v14 := compiler.MapValueForKey(m, "supportsSubscription")
		if v14 != nil {
			x.SupportsSubscription, ok = compiler.BoolForScalarNode(v14)
			if !ok {
				message := fmt.Sprintf("has unexpected value for supportsSubscription: %s", compiler.Display(v14))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string flat_path = 15;
		v15 := compiler.MapValueForKey(m, "flatPath")
		if v15 != nil {
			x.FlatPath, ok = compiler.StringForScalarNode(v15)
			if !ok {
				message := fmt.Sprintf("has unexpected value for flatPath: %s", compiler.Display(v15))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool etag_required = 16;
		v16 := compiler.MapValueForKey(m, "etagRequired")
		if v16 != nil {
			x.EtagRequired, ok = compiler.BoolForScalarNode(v16)
			if !ok {
				message := fmt.Sprintf("has unexpected value for etagRequired: %s", compiler.Display(v16))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string streaming_type = 17;
		v17 := compiler.MapValueForKey(m, "streamingType")
		if v17 != nil {
			x.StreamingType, ok = compiler.StringForScalarNode(v17)
			if !ok {
				message := fmt.Sprintf("has unexpected value for streamingType: %s", compiler.Display(v17))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewMethods creates an object of type Methods if possible, returning an error if not.
func NewMethods(in *yaml.Node, context *compiler.Context) (*Methods, error) {
	errors := make([]error, 0)
	x := &Methods{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		// repeated NamedMethod additional_properties = 1;
		// MAP: Method
		x.AdditionalProperties = make([]*NamedMethod, 0)
		for i := 0; i < len(m.Content); i += 2 {
			k, ok := compiler.StringForScalarNode(m.Content[i])
			if ok {
				v := m.Content[i+1]
				pair := &NamedMethod{}
				pair.Name = k
				var err error
				pair.Value, err = NewMethod(v, compiler.NewContext(k, v, context))
				if err != nil {
					errors = append(errors, err)
				}
				x.AdditionalProperties = append(x.AdditionalProperties, pair)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewNamedMethod creates an object of type NamedMethod if possible, returning an error if not.
func NewNamedMethod(in *yaml.Node, context *compiler.Context) (*NamedMethod, error) {
	errors := make([]error, 0)
	x := &NamedMethod{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"name", "value"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string name = 1;
		v1 := compiler.MapValueForKey(m, "name")
		if v1 != nil {
			x.Name, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for name: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Method value = 2;
		v2 := compiler.MapValueForKey(m, "value")
		if v2 != nil {
			var err error
			x.Value, err = NewMethod(v2, compiler.NewContext("value", v2, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewNamedParameter creates an object of type NamedParameter if possible, returning an error if not.
func NewNamedParameter(in *yaml.Node, context *compiler.Context) (*NamedParameter, error) {
	errors := make([]error, 0)
	x := &NamedParameter{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"name", "value"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string name = 1;
		v1 := compiler.MapValueForKey(m, "name")
		if v1 != nil {
			x.Name, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for name: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Parameter value = 2;
		v2 := compiler.MapValueForKey(m, "value")
		if v2 != nil {
			var err error
			x.Value, err = NewParameter(v2, compiler.NewContext("value", v2, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewNamedResource creates an object of type NamedResource if possible, returning an error if not.
func NewNamedResource(in *yaml.Node, context *compiler.Context) (*NamedResource, error) {
	errors := make([]error, 0)
	x := &NamedResource{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"name", "value"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string name = 1;
		v1 := compiler.MapValueForKey(m, "name")
		if v1 != nil {
			x.Name, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for name: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Resource value = 2;
		v2 := compiler.MapValueForKey(m, "value")
		if v2 != nil {
			var err error
			x.Value, err = NewResource(v2, compiler.NewContext("value", v2, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewNamedSchema creates an object of type NamedSchema if possible, returning an error if not.
func NewNamedSchema(in *yaml.Node, context *compiler.Context) (*NamedSchema, error) {
	errors := make([]error, 0)
	x := &NamedSchema{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"name", "value"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string name = 1;
		v1 := compiler.MapValueForKey(m, "name")
		if v1 != nil {
			x.Name, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for name: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Schema value = 2;
		v2 := compiler.MapValueForKey(m, "value")
		if v2 != nil {
			var err error
			x.Value, err = NewSchema(v2, compiler.NewContext("value", v2, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewNamedScope creates an object of type NamedScope if possible, returning an error if not.
func NewNamedScope(in *yaml.Node, context *compiler.Context) (*NamedScope, error) {
	errors := make([]error, 0)
	x := &NamedScope{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"name", "value"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string name = 1;
		v1 := compiler.MapValueForKey(m, "name")
		if v1 != nil {
			x.Name, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for name: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Scope value = 2;
		v2 := compiler.MapValueForKey(m, "value")
		if v2 != nil {
			var err error
			x.Value, err = NewScope(v2, compiler.NewContext("value", v2, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewOauth2 creates an object of type Oauth2 if possible, returning an error if not.
func NewOauth2(in *yaml.Node, context *compiler.Context) (*Oauth2, error) {
	errors := make([]error, 0)
	x := &Oauth2{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"scopes"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// Scopes scopes = 1;
		v1 := compiler.MapValueForKey(m, "scopes")
		if v1 != nil {
			var err error
			x.Scopes, err = NewScopes(v1, compiler.NewContext("scopes", v1, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewParameter creates an object of type Parameter if possible, returning an error if not.
func NewParameter(in *yaml.Node, context *compiler.Context) (*Parameter, error) {
	errors := make([]error, 0)
	x := &Parameter{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"$ref", "additionalProperties", "annotations", "default", "description", "enum", "enumDescriptions", "format", "id", "items", "location", "maximum", "minimum", "pattern", "properties", "repeated", "required", "type"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string id = 1;
		v1 := compiler.MapValueForKey(m, "id")
		if v1 != nil {
			x.Id, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for id: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string type = 2;
		v2 := compiler.MapValueForKey(m, "type")
		if v2 != nil {
			x.Type, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for type: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string _ref = 3;
		v3 := compiler.MapValueForKey(m, "$ref")
		if v3 != nil {
			x.XRef, ok = compiler.StringForScalarNode(v3)
			if !ok {
				message := fmt.Sprintf("has unexpected value for $ref: %s", compiler.Display(v3))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string description = 4;
		v4 := compiler.MapValueForKey(m, "description")
		if v4 != nil {
			x.Description, ok = compiler.StringForScalarNode(v4)
			if !ok {
				message := fmt.Sprintf("has unexpected value for description: %s", compiler.Display(v4))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string default = 5;
		v5 := compiler.MapValueForKey(m, "default")
		if v5 != nil {
			x.Default, ok = compiler.StringForScalarNode(v5)
			if !ok {
				message := fmt.Sprintf("has unexpected value for default: %s", compiler.Display(v5))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool required = 6;
		v6 := compiler.MapValueForKey(m, "required")
		if v6 != nil {
			x.Required, ok = compiler.BoolForScalarNode(v6)
			if !ok {
				message := fmt.Sprintf("has unexpected value for required: %s", compiler.Display(v6))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string format = 7;
		v7 := compiler.MapValueForKey(m, "format")
		if v7 != nil {
			x.Format, ok = compiler.StringForScalarNode(v7)
			if !ok {
				message := fmt.Sprintf("has unexpected value for format: %s", compiler.Display(v7))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string pattern = 8;
		v8 := compiler.MapValueForKey(m, "pattern")
		if v8 != nil {
			x.Pattern, ok = compiler.StringForScalarNode(v8)
			if !ok {
				message := fmt.Sprintf("has unexpected value for pattern: %s", compiler.Display(v8))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string minimum = 9;
		v9 := compiler.MapValueForKey(m, "minimum")
		if v9 != nil {
			x.Minimum, ok = compiler.StringForScalarNode(v9)
			if !ok {
				message := fmt.Sprintf("has unexpected value for minimum: %s", compiler.Display(v9))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string maximum = 10;
		v10 := compiler.MapValueForKey(m, "maximum")
		if v10 != nil {
			x.Maximum, ok = compiler.StringForScalarNode(v10)
			if !ok {
				message := fmt.Sprintf("has unexpected value for maximum: %s", compiler.Display(v10))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// repeated string enum = 11;
		v11 := compiler.MapValueForKey(m, "enum")
		if v11 != nil {
			v, ok := compiler.SequenceNodeForNode(v11)
			if ok {
				x.Enum = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for enum: %s", compiler.Display(v11))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// repeated string enum_descriptions = 12;
		v12 := compiler.MapValueForKey(m, "enumDescriptions")
		if v12 != nil {
			v, ok := compiler.SequenceNodeForNode(v12)
			if ok {
				x.EnumDescriptions = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for enumDescriptions: %s", compiler.Display(v12))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool repeated = 13;
		v13 := compiler.MapValueForKey(m, "repeated")
		if v13 != nil {
			x.Repeated, ok = compiler.BoolForScalarNode(v13)
			if !ok {
				message := fmt.Sprintf("has unexpected value for repeated: %s", compiler.Display(v13))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string location = 14;
		v14 := compiler.MapValueForKey(m, "location")
		if v14 != nil {
			x.Location, ok = compiler.StringForScalarNode(v14)
			if !ok {
				message := fmt.Sprintf("has unexpected value for location: %s", compiler.Display(v14))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Schemas properties = 15;
		v15 := compiler.MapValueForKey(m, "properties")
		if v15 != nil {
			var err error
			x.Properties, err = NewSchemas(v15, compiler.NewContext("properties", v15, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Schema additional_properties = 16;
		v16 := compiler.MapValueForKey(m, "additionalProperties")
		if v16 != nil {
			var err error
			x.AdditionalProperties, err = NewSchema(v16, compiler.NewContext("additionalProperties", v16, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Schema items = 17;
		v17 := compiler.MapValueForKey(m, "items")
		if v17 != nil {
			var err error
			x.Items, err = NewSchema(v17, compiler.NewContext("items", v17, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Annotations annotations = 18;
		v18 := compiler.MapValueForKey(m, "annotations")
		if v18 != nil {
			var err error
			x.Annotations, err = NewAnnotations(v18, compiler.NewContext("annotations", v18, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewParameters creates an object of type Parameters if possible, returning an error if not.
func NewParameters(in *yaml.Node, context *compiler.Context) (*Parameters, error) {
	errors := make([]error, 0)
	x := &Parameters{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		// repeated NamedParameter additional_properties = 1;
		// MAP: Parameter
		x.AdditionalProperties = make([]*NamedParameter, 0)
		for i := 0; i < len(m.Content); i += 2 {
			k, ok := compiler.StringForScalarNode(m.Content[i])
			if ok {
				v := m.Content[i+1]
				pair := &NamedParameter{}
				pair.Name = k
				var err error
				pair.Value, err = NewParameter(v, compiler.NewContext(k, v, context))
				if err != nil {
					errors = append(errors, err)
				}
				x.AdditionalProperties = append(x.AdditionalProperties, pair)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewProtocols creates an object of type Protocols if possible, returning an error if not.
func NewProtocols(in *yaml.Node, context *compiler.Context) (*Protocols, error) {
	errors := make([]error, 0)
	x := &Protocols{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"resumable", "simple"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// Simple simple = 1;
		v1 := compiler.MapValueForKey(m, "simple")
		if v1 != nil {
			var err error
			x.Simple, err = NewSimple(v1, compiler.NewContext("simple", v1, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Resumable resumable = 2;
		v2 := compiler.MapValueForKey(m, "resumable")
		if v2 != nil {
			var err error
			x.Resumable, err = NewResumable(v2, compiler.NewContext("resumable", v2, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewRequest creates an object of type Request if possible, returning an error if not.
func NewRequest(in *yaml.Node, context *compiler.Context) (*Request, error) {
	errors := make([]error, 0)
	x := &Request{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"$ref", "parameterName"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string _ref = 1;
		v1 := compiler.MapValueForKey(m, "$ref")
		if v1 != nil {
			x.XRef, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for $ref: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string parameter_name = 2;
		v2 := compiler.MapValueForKey(m, "parameterName")
		if v2 != nil {
			x.ParameterName, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for parameterName: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewResource creates an object of type Resource if possible, returning an error if not.
func NewResource(in *yaml.Node, context *compiler.Context) (*Resource, error) {
	errors := make([]error, 0)
	x := &Resource{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"methods", "resources"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// Methods methods = 1;
		v1 := compiler.MapValueForKey(m, "methods")
		if v1 != nil {
			var err error
			x.Methods, err = NewMethods(v1, compiler.NewContext("methods", v1, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Resources resources = 2;
		v2 := compiler.MapValueForKey(m, "resources")
		if v2 != nil {
			var err error
			x.Resources, err = NewResources(v2, compiler.NewContext("resources", v2, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewResources creates an object of type Resources if possible, returning an error if not.
func NewResources(in *yaml.Node, context *compiler.Context) (*Resources, error) {
	errors := make([]error, 0)
	x := &Resources{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		// repeated NamedResource additional_properties = 1;
		// MAP: Resource
		x.AdditionalProperties = make([]*NamedResource, 0)
		for i := 0; i < len(m.Content); i += 2 {
			k, ok := compiler.StringForScalarNode(m.Content[i])
			if ok {
				v := m.Content[i+1]
				pair := &NamedResource{}
				pair.Name = k
				var err error
				pair.Value, err = NewResource(v, compiler.NewContext(k, v, context))
				if err != nil {
					errors = append(errors, err)
				}
				x.AdditionalProperties = append(x.AdditionalProperties, pair)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewResponse creates an object of type Response if possible, returning an error if not.
func NewResponse(in *yaml.Node, context *compiler.Context) (*Response, error) {
	errors := make([]error, 0)
	x := &Response{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"$ref"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string _ref = 1;
		v1 := compiler.MapValueForKey(m, "$ref")
		if v1 != nil {
			x.XRef, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for $ref: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewResumable creates an object of type Resumable if possible, returning an error if not.
func NewResumable(in *yaml.Node, context *compiler.Context) (*Resumable, error) {
	errors := make([]error, 0)
	x := &Resumable{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"multipart", "path"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// bool multipart = 1;
		v1 := compiler.MapValueForKey(m, "multipart")
		if v1 != nil {
			x.Multipart, ok = compiler.BoolForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for multipart: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string path = 2;
		v2 := compiler.MapValueForKey(m, "path")
		if v2 != nil {
			x.Path, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for path: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewSchema creates an object of type Schema if possible, returning an error if not.
func NewSchema(in *yaml.Node, context *compiler.Context) (*Schema, error) {
	errors := make([]error, 0)
	x := &Schema{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"$ref", "additionalProperties", "annotations", "default", "description", "enum", "enumDescriptions", "format", "id", "items", "location", "maximum", "minimum", "pattern", "properties", "readOnly", "repeated", "required", "type"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string id = 1;
		v1 := compiler.MapValueForKey(m, "id")
		if v1 != nil {
			x.Id, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for id: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string type = 2;
		v2 := compiler.MapValueForKey(m, "type")
		if v2 != nil {
			x.Type, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for type: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string description = 3;
		v3 := compiler.MapValueForKey(m, "description")
		if v3 != nil {
			x.Description, ok = compiler.StringForScalarNode(v3)
			if !ok {
				message := fmt.Sprintf("has unexpected value for description: %s", compiler.Display(v3))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string default = 4;
		v4 := compiler.MapValueForKey(m, "default")
		if v4 != nil {
			x.Default, ok = compiler.StringForScalarNode(v4)
			if !ok {
				message := fmt.Sprintf("has unexpected value for default: %s", compiler.Display(v4))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool required = 5;
		v5 := compiler.MapValueForKey(m, "required")
		if v5 != nil {
			x.Required, ok = compiler.BoolForScalarNode(v5)
			if !ok {
				message := fmt.Sprintf("has unexpected value for required: %s", compiler.Display(v5))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string format = 6;
		v6 := compiler.MapValueForKey(m, "format")
		if v6 != nil {
			x.Format, ok = compiler.StringForScalarNode(v6)
			if !ok {
				message := fmt.Sprintf("has unexpected value for format: %s", compiler.Display(v6))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string pattern = 7;
		v7 := compiler.MapValueForKey(m, "pattern")
		if v7 != nil {
			x.Pattern, ok = compiler.StringForScalarNode(v7)
			if !ok {
				message := fmt.Sprintf("has unexpected value for pattern: %s", compiler.Display(v7))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string minimum = 8;
		v8 := compiler.MapValueForKey(m, "minimum")
		if v8 != nil {
			x.Minimum, ok = compiler.StringForScalarNode(v8)
			if !ok {
				message := fmt.Sprintf("has unexpected value for minimum: %s", compiler.Display(v8))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string maximum = 9;
		v9 := compiler.MapValueForKey(m, "maximum")
		if v9 != nil {
			x.Maximum, ok = compiler.StringForScalarNode(v9)
			if !ok {
				message := fmt.Sprintf("has unexpected value for maximum: %s", compiler.Display(v9))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// repeated string enum = 10;
		v10 := compiler.MapValueForKey(m, "enum")
		if v10 != nil {
			v, ok := compiler.SequenceNodeForNode(v10)
			if ok {
				x.Enum = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for enum: %s", compiler.Display(v10))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// repeated string enum_descriptions = 11;
		v11 := compiler.MapValueForKey(m, "enumDescriptions")
		if v11 != nil {
			v, ok := compiler.SequenceNodeForNode(v11)
			if ok {
				x.EnumDescriptions = compiler.StringArrayForSequenceNode(v)
			} else {
				message := fmt.Sprintf("has unexpected value for enumDescriptions: %s", compiler.Display(v11))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// bool repeated = 12;
		v12 := compiler.MapValueForKey(m, "repeated")
		if v12 != nil {
			x.Repeated, ok = compiler.BoolForScalarNode(v12)
			if !ok {
				message := fmt.Sprintf("has unexpected value for repeated: %s", compiler.Display(v12))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string location = 13;
		v13 := compiler.MapValueForKey(m, "location")
		if v13 != nil {
			x.Location, ok = compiler.StringForScalarNode(v13)
			if !ok {
				message := fmt.Sprintf("has unexpected value for location: %s", compiler.Display(v13))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Schemas properties = 14;
		v14 := compiler.MapValueForKey(m, "properties")
		if v14 != nil {
			var err error
			x.Properties, err = NewSchemas(v14, compiler.NewContext("properties", v14, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Schema additional_properties = 15;
		v15 := compiler.MapValueForKey(m, "additionalProperties")
		if v15 != nil {
			var err error
			x.AdditionalProperties, err = NewSchema(v15, compiler.NewContext("additionalProperties", v15, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// Schema items = 16;
		v16 := compiler.MapValueForKey(m, "items")
		if v16 != nil {
			var err error
			x.Items, err = NewSchema(v16, compiler.NewContext("items", v16, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// string _ref = 17;
		v17 := compiler.MapValueForKey(m, "$ref")
		if v17 != nil {
			x.XRef, ok = compiler.StringForScalarNode(v17)
			if !ok {
				message := fmt.Sprintf("has unexpected value for $ref: %s", compiler.Display(v17))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// Annotations annotations = 18;
		v18 := compiler.MapValueForKey(m, "annotations")
		if v18 != nil {
			var err error
			x.Annotations, err = NewAnnotations(v18, compiler.NewContext("annotations", v18, context))
			if err != nil {
				errors = append(errors, err)
			}
		}
		// bool read_only = 19;
		v19 := compiler.MapValueForKey(m, "readOnly")
		if v19 != nil {
			x.ReadOnly, ok = compiler.BoolForScalarNode(v19)
			if !ok {
				message := fmt.Sprintf("has unexpected value for readOnly: %s", compiler.Display(v19))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewSchemas creates an object of type Schemas if possible, returning an error if not.
func NewSchemas(in *yaml.Node, context *compiler.Context) (*Schemas, error) {
	errors := make([]error, 0)
	x := &Schemas{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		// repeated NamedSchema additional_properties = 1;
		// MAP: Schema
		x.AdditionalProperties = make([]*NamedSchema, 0)
		for i := 0; i < len(m.Content); i += 2 {
			k, ok := compiler.StringForScalarNode(m.Content[i])
			if ok {
				v := m.Content[i+1]
				pair := &NamedSchema{}
				pair.Name = k
				var err error
				pair.Value, err = NewSchema(v, compiler.NewContext(k, v, context))
				if err != nil {
					errors = append(errors, err)
				}
				x.AdditionalProperties = append(x.AdditionalProperties, pair)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewScope creates an object of type Scope if possible, returning an error if not.
func NewScope(in *yaml.Node, context *compiler.Context) (*Scope, error) {
	errors := make([]error, 0)
	x := &Scope{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"description"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// string description = 1;
		v1 := compiler.MapValueForKey(m, "description")
		if v1 != nil {
			x.Description, ok = compiler.StringForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for description: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewScopes creates an object of type Scopes if possible, returning an error if not.
func NewScopes(in *yaml.Node, context *compiler.Context) (*Scopes, error) {
	errors := make([]error, 0)
	x := &Scopes{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		// repeated NamedScope additional_properties = 1;
		// MAP: Scope
		x.AdditionalProperties = make([]*NamedScope, 0)
		for i := 0; i < len(m.Content); i += 2 {
			k, ok := compiler.StringForScalarNode(m.Content[i])
			if ok {
				v := m.Content[i+1]
				pair := &NamedScope{}
				pair.Name = k
				var err error
				pair.Value, err = NewScope(v, compiler.NewContext(k, v, context))
				if err != nil {
					errors = append(errors, err)
				}
				x.AdditionalProperties = append(x.AdditionalProperties, pair)
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewSimple creates an object of type Simple if possible, returning an error if not.
func NewSimple(in *yaml.Node, context *compiler.Context) (*Simple, error) {
	errors := make([]error, 0)
	x := &Simple{}
	m, ok := compiler.UnpackMap(in)
	if !ok {
		message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
		errors = append(errors, compiler.NewError(context, message))
	} else {
		allowedKeys := []string{"multipart", "path"}
		var allowedPatterns []*regexp.Regexp
		invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
		if len(invalidKeys) > 0 {
			message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
			errors = append(errors, compiler.NewError(context, message))
		}
		// bool multipart = 1;
		v1 := compiler.MapValueForKey(m, "multipart")
		if v1 != nil {
			x.Multipart, ok = compiler.BoolForScalarNode(v1)
			if !ok {
				message := fmt.Sprintf("has unexpected value for multipart: %s", compiler.Display(v1))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
		// string path = 2;
		v2 := compiler.MapValueForKey(m, "path")
		if v2 != nil {
			x.Path, ok = compiler.StringForScalarNode(v2)
			if !ok {
				message := fmt.Sprintf("has unexpected value for path: %s", compiler.Display(v2))
				errors = append(errors, compiler.NewError(context, message))
			}
		}
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}

// NewStringArray creates an object of type StringArray if possible, returning an error if not.
func NewStringArray(in *yaml.Node, context *compiler.Context) (*StringArray, error) {
	errors := make([]error, 0)
	x := &StringArray{}
	x.Value = make([]string, 0)
	for _, node := range in.Content {
		s, _ := compiler.StringForScalarNode(node)
		x.Value = append(x.Value, s)
	}
	return x, compiler.NewErrorGroupOrNil(errors)
}
